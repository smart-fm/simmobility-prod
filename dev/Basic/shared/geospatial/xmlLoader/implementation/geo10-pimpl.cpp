// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//
#include "geo10-pimpl.hpp"

#include <cstdio>
#include <iostream>
#include <boost/bimap.hpp>
#include "util/OpaqueProperty.hpp"


#include <boost/multi_index_container.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/random_access_index.hpp>
#include <boost/multi_index/composite_key.hpp>
#include <boost/multi_index/mem_fun.hpp>
using boost::multi_index::get;


namespace sim_mob {
namespace xml {

//int tmp_cnn_cnt = 0;
//int tmp_rs = 0;
struct geo_LinkLoc_mapping
{
	geo_LinkLoc_mapping(unsigned int linkID_=0,std::vector<sim_mob::Node*> node_=std::vector<sim_mob::Node*>(),sim_mob::Node *rawNode_=0):
		linkID(linkID_),
//		node1(node1_),
//		node2(node2_),
		node(node_),
		rawNode(rawNode_){}
	geo_LinkLoc_mapping(unsigned int linkID_=0,sim_mob::Node *rawNode_=0):
		linkID(linkID_),
		rawNode(rawNode_){}
	mutable unsigned long linkID;
//	mutable sim_mob::Node* node1;//can be starting node or ending node
//	mutable sim_mob::Node* node2;//can be starting node or ending node
	mutable std::vector<sim_mob::Node*> node;
	mutable sim_mob::Node *rawNode;//store temporary node created when reading basic node
};
typedef boost::multi_index_container<
		geo_LinkLoc_mapping,
		boost::multi_index::indexed_by<
		boost::multi_index::random_access<>//0
		,boost::multi_index::ordered_unique<boost::multi_index::member<geo_LinkLoc_mapping, unsigned long , &geo_LinkLoc_mapping::linkID> >//1
//		,boost::multi_index::ordered_non_unique<boost::multi_index::member<geo_LinkLoc_mapping, sim_mob::Node* , &geo_LinkLoc_mapping::node1> >//2
//		,boost::multi_index::ordered_non_unique<boost::multi_index::member<geo_LinkLoc_mapping, sim_mob::Node* , &geo_LinkLoc_mapping::node2> >//3
		,boost::multi_index::ordered_non_unique<boost::multi_index::member<geo_LinkLoc_mapping, sim_mob::Node* , &geo_LinkLoc_mapping::rawNode> >//2
									  >
									>geo_LinkLoc;
typedef boost::multi_index::nth_index<geo_LinkLoc, 0>::type geo_LinkLoc_random;
typedef boost::multi_index::nth_index<geo_LinkLoc, 1>::type geo_LinkLoc_linkID;
typedef boost::multi_index::nth_index<geo_LinkLoc, 2>::type geo_LinkLoc_rawNode;
//geo_LinkLoc_linkID::iterator geo_LinkLoc_linkID_it;
geo_LinkLoc geo_LinkLoc_;
std::map<unsigned int,sim_mob::Link*> geo_Links_;
std::map<unsigned long,sim_mob::RoadSegment*> geo_Segments_;
std::map<unsigned long,sim_mob::Lane*> geo_Lanes_;

std::map<unsigned int,std::set<unsigned long> > geo_RoadSegmentsAt; //<nodeId,set<segments>>
std::map<unsigned int, std::pair<std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long> > > geo_UniNode_SegmentPairs; //map<nodeId, pair< pair<segId,SegId> , pair<segId,segId> >

helper::UniNodeConnectors geo_UniNode_Connectors;//todo
//std::map<unsigned int,helper::UniNodeConnectors> geo_UniNodeConnectorsMap;//<nodeId,helper::UniNodeConnectors>
std::map<unsigned int,helper::MultiNodeConnectors> geo_MultiNodeConnectorsMap;//map <nodeId,helper::MultiNodeConnectors> or map <nodeId,map<roadsegment,set<pair<lanefrom,laneto>> > >

struct BusStopInfo
{
	sim_mob::BusStop *busStop;
	unsigned long lane_location;
	BusStopInfo()
	{
		busStop = 0;
		lane_location = -1;
	}
} bs_info;

std::map<unsigned long,BusStopInfo> geo_BusStop_; // map<busstopid,BusStopInfo>

// lane_t_pimpl
//


// connector_t_pimpl
//



// connectors_t_pimpl
//


// Multi_Connector_t_pimpl
//



// Multi_Connectors_t_pimpl
//



// fwdBckSegments_t_pimpl
//



// RoadSegmentsAt_t_pimpl
//



// laneEdgePolyline_cached_t_pimpl
//



// laneEdgePolylines_cached_t_pimpl
//



// segment_t_pimpl
//



// link_t_pimpl
//



// separator_t_pimpl
//



// separators_t_pimpl
//



// DomainIsland_t_pimpl
//



// DomainIslands_t_pimpl
//



// offset_t_pimpl
//



// offsets_t_pimpl
//



// ChunkLength_t_pimpl
//



// ChunkLengths_t_pimpl
//


// LanesVector_t_pimpl
//



// EntranceAngle_t_pimpl
//



// EntranceAngles_t_pimpl
//



// Node_t_pimpl
//



// UniNode_t_pimpl
//


// roundabout_t_pimpl
//

void roundabout_t_pimpl::
pre ()
{
}

void roundabout_t_pimpl::
roadSegmentsAt (std::set<unsigned long> roadSegmentsAt)
{
  // TODO
  //
}

void roundabout_t_pimpl::
Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >& Connectors)
{
  // TODO
  //
}

void roundabout_t_pimpl::
ChunkLengths ()
{
}

void roundabout_t_pimpl::
Offsets ()
{
}

void roundabout_t_pimpl::
Separators ()
{
}

void roundabout_t_pimpl::
addDominantLane ()
{
}

void roundabout_t_pimpl::
roundaboutDominantIslands (float roundaboutDominantIslands)
{
  std::cout << "roundaboutDominantIslands: " << roundaboutDominantIslands << std::endl;
}

void roundabout_t_pimpl::
roundaboutNumberOfLanes (int roundaboutNumberOfLanes)
{
  std::cout << "roundaboutNumberOfLanes: " << roundaboutNumberOfLanes << std::endl;
}

void roundabout_t_pimpl::
entranceAngles ()
{
}

sim_mob::MultiNode* roundabout_t_pimpl::
post_roundabout_t ()
{
  sim_mob::Node* v (post_Node_t ());
}

// intersection_t_pimpl
//

void intersection_t_pimpl::
pre ()
{
	Node_t_pimpl::pre();
}

void intersection_t_pimpl::
roadSegmentsAt (std::set<unsigned long> roadSegmentsAt)
{
	  roadSegmentsAt_ = roadSegmentsAt;
//	  std::cout << "intersection_pimpl::roadSegmentsAt()\n";
//	  for(std::set<std::string>::iterator it = roadSegmentsAt.begin(), it_end(roadSegmentsAt.end()); it != it_end ; it++)
//		  geo_RoadSegmentsAt.insert(std::pair<unsigned int,std::string>(this->intersection->getID(),(*it)));//with assumption that nodes precede links in XML
//	  std::cout << "intersection_pimpl::roadSegmentsAt()-Done\n";
}

void intersection_t_pimpl::
Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >& Connectors)
{
	  this->connectors_ = Connectors;
}

void intersection_t_pimpl::
ChunkLengths ()
{
}

void intersection_t_pimpl::
Offsets ()
{
}

void intersection_t_pimpl::
Separators ()
{
}

void intersection_t_pimpl::
additionalDominantLanes ()
{
}

void intersection_t_pimpl::
additionalSubdominantLanes ()
{
}

void intersection_t_pimpl::
domainIslands ()
{
}

sim_mob::MultiNode* intersection_t_pimpl::
post_intersection_t ()
{
  sim_mob::Node* v (post_Node_t ());
    this->intersection = new sim_mob::Intersection(v->getLocation().getX(), v->getLocation().getY());
	   this->intersection->setID(v->getID());
	   this->intersection->originalDB_ID = v->originalDB_ID;
//		  std::cout << "In intersection_t_pimpl::post_intersection_t ()->originalDB_ID" << this->intersection->originalDB_ID.getLogItem()  << "(" << v->originalDB_ID.repr_ << ")\n";
//	   std::cout << "location of intersection node is at [" << this->intersection->getLocation().getX() << " , " << this->intersection->getLocation().getY() << std::endl;

	   //geo_Nodes_[v->getID()] = this->intersection;
	   Nodes_pimpl::RegisterNode(v->getID(), this->intersection);

	   geo_MultiNodeConnectorsMap[v->getID()] = this->connectors_;
  geo_RoadSegmentsAt[v->getID()] = this->roadSegmentsAt_;
	    geo_LinkLoc_rawNode & container = get<2>(geo_LinkLoc_);
	    geo_LinkLoc_rawNode::iterator it = container.find(v);

  if(it == container.end())
  {
  	std::cout << "Couldn't find the basic node " << v <<  " with container size(" << container.size() << "):\n" ;
  	for(it= container.begin(); it != container.end(); it++)
  		std::cout << it->rawNode << std::endl;
  }
  else
  {
//    	std::cout << "Found the  basic node " << v <<  " container size(" << container.size() << ")" << std::endl;
  	it->node.push_back(this->intersection);
  }

//    delete v;
	  return this->intersection;
}


// RoadItem_t_pimpl
//

void RoadItem_t_pimpl::
pre ()
{
	    std::cout << "in RoadItem_t_pimpl::pre  " << std::endl;
}

void RoadItem_t_pimpl::
id (unsigned long long id)
{
  std::cout << "id: " << id << std::endl;
  id_ = id;
}

void RoadItem_t_pimpl::
Offset (unsigned short Offset)
{
  std::cout << "in RoadItem_t_pimpl::Offset: " << Offset << std::endl;
  Offset_ = Offset;
}

void RoadItem_t_pimpl::
start (sim_mob::Point2D start)
{
	  std::cout << "in RoadItem_t_pimpl::start\n";
	  start_ = start;
}

void RoadItem_t_pimpl::
end (sim_mob::Point2D end)
{
	  std::cout << "in RoadItem_t_pimpl::end\n";
	  end_ = end;
}

std::pair<unsigned long,sim_mob::RoadItem*> RoadItem_t_pimpl::
post_RoadItem_t ()
{
	  std::cout << "in RoadItem_t_pimpl::post_RoadItem_t\n";

	  sim_mob::RoadItem *ri = new sim_mob::RoadItem;
	  ri->id = id_;
	  ri->start = start_;
	  ri->end = end_;

	  return std::make_pair(Offset_,ri);
}

// BusStop_t_pimpl
//

void BusStop_t_pimpl::
pre ()
{
	    std::cout << "in BusStop_t_pimpl::pre ()\n";
	    bs = new sim_mob::BusStop();
	    bs_info = BusStopInfo();
	    bs_info.busStop = bs;
}

void BusStop_t_pimpl::
xPos (double xPos)
{
  std::cout << "xPos: " << xPos << std::endl;
  bs->xPos = xPos;
}

void BusStop_t_pimpl::
yPos (double yPos)
{
  std::cout << "yPos: " << yPos << std::endl;
  bs->yPos = yPos;
}

void BusStop_t_pimpl::
lane_location (unsigned long long lane_location)
{
  std::cout << "lane_location: " << lane_location << std::endl;
  bs_info.lane_location = lane_location;
}

void BusStop_t_pimpl::
is_terminal (bool is_terminal)
{
  std::cout << "is_Terminal: " << is_terminal << std::endl;
  bs->is_terminal = is_terminal;
}

void BusStop_t_pimpl::
is_bay (bool is_bay)
{
  std::cout << "is_Bay: " << is_bay << std::endl;
  bs->is_bay = is_bay;
}

void BusStop_t_pimpl::
has_shelter (bool has_shelter)
{
  std::cout << "has_shelter: " << has_shelter << std::endl;
  bs->has_shelter = has_shelter;
}

void BusStop_t_pimpl::
busCapacityAsLength (unsigned int busCapacityAsLength)
{
  std::cout << "busCapacityAsLength: " << busCapacityAsLength << std::endl;
  bs->busCapacityAsLength = busCapacityAsLength;
}

void BusStop_t_pimpl::
busstopno (const ::std::string& busstopno)
{
  std::cout << "busstopno: " << busstopno << std::endl;
  bs->busstopno_ = busstopno;
}

std::pair<unsigned long,sim_mob::BusStop*> BusStop_t_pimpl::
post_BusStop_t ()
{
  std::pair<unsigned long,sim_mob::RoadItem*> v (post_RoadItem_t ());
  bs->id = v.second->getRoadItemID();
  bs->start = v.second->getStart();
  bs->end = v.second->getEnd();
  delete v.second; //cleanup
  return std::make_pair(v.first, bs);

  // TODO
  //
}

// ERP_Gantry_t_pimpl
//

void ERP_Gantry_t_pimpl::
pre ()
{
}

void ERP_Gantry_t_pimpl::
ERP_GantryID (const ::std::string& ERP_GantryID)
{
  std::cout << "ERP_GantryID: " << ERP_GantryID << std::endl;
}

void ERP_Gantry_t_pimpl::
post_ERP_Gantry_t ()
{
  std::pair<unsigned long,sim_mob::RoadItem*> v (post_RoadItem_t ());

  // TODO
  //
}

// FormType_pimpl
//

void FormType_pimpl::
pre ()
{
}

void FormType_pimpl::
TextBox (int TextBox)
{
  std::cout << "TextBox: " << TextBox << std::endl;
}

void FormType_pimpl::
TextArea (int TextArea)
{
  std::cout << "TextArea: " << TextArea << std::endl;
}

void FormType_pimpl::
Header (int Header)
{
  std::cout << "Header: " << Header << std::endl;
}

void FormType_pimpl::
post_FormType ()
{
}

// PointPair_t_pimpl
//

void PointPair_t_pimpl::
pre ()
{
}

void PointPair_t_pimpl::
first (sim_mob::Point2D first)
{
	  pointPair.first = first;
}

void PointPair_t_pimpl::
second (sim_mob::Point2D second)
{
	  pointPair.second = second;
}

std::pair<sim_mob::Point2D,sim_mob::Point2D> PointPair_t_pimpl::
post_PointPair_t ()
{
	  return pointPair;
}

// crossing_t_pimpl
//

void crossing_t_pimpl::
pre ()
{

	  std::cout << "in crossing_t_pimpl::pre () " << std::endl;
	    crossing = new sim_mob::Crossing();
    }

void crossing_t_pimpl::
nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D> nearLine)
{
	  crossing->nearLine.first = nearLine.first;
	  crossing->nearLine.second = nearLine.second;
}

void crossing_t_pimpl::
farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D> farLine)
{
	  crossing->farLine.first = farLine.first;
	  crossing->farLine.second = farLine.second;
}

std::pair<unsigned long,sim_mob::Crossing*> crossing_t_pimpl::
post_crossing_t ()
{
  std::pair<unsigned long,sim_mob::RoadItem*> v (post_RoadItem_t ());

//    sim_mob::Crossing* crossing = new sim_mob::Crossing();
	crossing->id = v.second->getRoadItemID();
  crossing->start = v.second->getStart();
  crossing->end   = v.second->getEnd();
  delete v.second; //cleanup
  return std::make_pair(v.first, crossing);
}

// RoadBump_t_pimpl
//

void RoadBump_t_pimpl::
pre ()
{
}

void RoadBump_t_pimpl::
roadBumpID (const ::std::string& roadBumpID)
{
  std::cout << "roadBumpID: " << roadBumpID << std::endl;
}

void RoadBump_t_pimpl::
segmentID (unsigned long long segmentID)
{
//    std::cout << "segmentID: " << segmentID << std::endl;
}

void RoadBump_t_pimpl::
post_RoadBump_t ()
{
  std::pair<unsigned long,sim_mob::RoadItem*> v (post_RoadItem_t ());

  // TODO
  //
}

// RoadNetwork_t_pimpl
//
RoadNetwork_t_pimpl::
RoadNetwork_t_pimpl():rn(sim_mob::ConfigParams::GetInstance().getNetworkRW())
{

}
void RoadNetwork_t_pimpl::
pre ()
{
//	  rn = sim_mob::ConfigParams::GetInstance().getNetworkRW();
	  std::cout << "In RoadNetwork_t_pimpl::pre\n";
}

void RoadNetwork_t_pimpl::
Nodes ()
{
}

void RoadNetwork_t_pimpl::
Links (std::vector<sim_mob::Link*> Links)
{
	  rn.setLinks(Links);
	  std::cout << "Links Done	\n";
}

void RoadNetwork_t_pimpl::
post_RoadNetwork_t ()
{
}

// RoadItems_t_pimpl
//

void RoadItems_t_pimpl::
pre ()
{
	  std::cout << "in RoadItems_t_pimpl::pre () " << std::endl;
	  RoadItems.clear();
}

void RoadItems_t_pimpl::
BusStop (std::pair<unsigned long,sim_mob::BusStop*> BusStop)
{
	  RoadItems[BusStop.first] = BusStop.second;
}

void RoadItems_t_pimpl::
ERP_Gantry ()
{
}

void RoadItems_t_pimpl::
Crossing (std::pair<unsigned long,sim_mob::Crossing*> Crossing)
{
	  std::cout << "in RoadItems_t_pimpl::Crossing () " << std::endl;
	  RoadItems[Crossing.first] = Crossing.second;
}

void RoadItems_t_pimpl::
RoadBump ()
{
}

std::map<sim_mob::centimeter_t,const RoadItem*> RoadItems_t_pimpl::
post_RoadItems_t ()
{

	  std::cout << "in RoadItems_t_pimpl::post_RoadItems_t () " << std::endl;
	  return RoadItems;

}

// TripchainItemType_pimpl
//

void TripchainItemType_pimpl::
pre ()
{
}

std::string TripchainItemType_pimpl::
post_TripchainItemType ()
{
	  const ::std::string& v (post_string ());

  return v;
}

// TripchainItemLocationType_pimpl
//

void TripchainItemLocationType_pimpl::
pre ()
{
}

std::string TripchainItemLocationType_pimpl::
post_TripchainItemLocationType ()
{
	  const ::std::string& v (post_string ());
	  return v;
}

// TripChainItem_t_pimpl
//

void TripChainItem_t_pimpl::
pre ()
{
}

void TripChainItem_t_pimpl::
personID (long long personID)
{
	  std::cout << "TripChainItem_t_pimpl::personID() "  << std::endl;
	  this->personID_ = personID;
}

void TripChainItem_t_pimpl::
itemType (std::string itemType)
{
	  std::cout << "TripChainItem_t_pimpl::itemType() "  << std::endl;
	  this->itemType_ = itemType;
}

void TripChainItem_t_pimpl::
sequenceNumber (unsigned int sequenceNumber)
{
	  std::cout << "TripChainItem_t_pimpl::sequenceNumber() "  << std::endl;
	  this->sequenceNumber_ = sequenceNumber;
}

void TripChainItem_t_pimpl::
startTime (const ::std::string& startTime)
{
	  std::cout << "TripChainItem_t_pimpl::startTime() "  << std::endl;
	  this->startTime_ = startTime;
}

void TripChainItem_t_pimpl::
endTime (const ::std::string& endTime)
{
	  std::cout << "TripChainItem_t_pimpl::endTime() "  << std::endl;
	  this->endTime_ = endTime;
	  std::cout << "endTime: " << endTime << std::endl;
}

sim_mob::TripChainItem::ItemType gettripChainItemType(std::string itemType_)
{
	sim_mob::TripChainItem::ItemType ItemType;

	  if(itemType_ == "IT_TRIP")
		  ItemType = sim_mob::TripChainItem::IT_TRIP;
	  else
		  if(itemType_ ==  "IT_ACTIVITY")
		  ItemType = sim_mob::TripChainItem::IT_ACTIVITY;
	  return ItemType;
}
sim_mob::TripChainItem* TripChainItem_t_pimpl::
post_TripChainItem_t ()
{
	  this->tcItem = new sim_mob::TripChainItem();
	  this->tcItem->personID = this->personID_;

	  this->tcItem->itemType = gettripChainItemType(this->itemType_);

	  this->tcItem->sequenceNumber = sequenceNumber_;

	  //This should be equivalent. ~Seth
	  this->tcItem->startTime = DailyTime(startTime_);
	  //this->tcItem->startTime.repr_ = startTime_;
	  //this->tcItem->startTime.time_= sim_mob::DailyTime().ParseStringRepr(startTime_);


	  //This should be equivalent. ~Seth
	  this->tcItem->endTime = DailyTime(endTime_);
	  //this->tcItem->endTime.repr_ = endTime_;
	  //this->tcItem->endTime.time_= sim_mob::DailyTime().ParseStringRepr(endTime_);

	  std::cout << "TripChainItem_t_pimpl::post_TripChainItem_t() "  << std::endl;
	  //nullify the member variable,just in case
	  sim_mob::TripChainItem * temp_tripChainItem = 0;
	  temp_tripChainItem = this->tcItem;
	  this->tcItem = 0;
	  //now return the object pointer
	  return temp_tripChainItem;

}

// Trip_t_pimpl
//

void Trip_t_pimpl::
pre ()
{
	    std::cout << "In Trip_t_pimpl::pre ()" << std::endl;
	  trip = new sim_mob::Trip();
}

void Trip_t_pimpl::
tripID (long long tripID)
{
	  if(!trip) trip = new sim_mob::Trip();
	    std::cout << "In Trip_t_pimpl::tripID ()" << tripID << std::endl;
	  trip->tripID = tripID;

}

void Trip_t_pimpl::
fromLocation (unsigned int value)
{
	  if(!trip) return;
	  std::cout << "In Trip_t_pimpl::fromLocation ()"  << std::endl;

	  //trip->fromLocation = geo_Nodes_[fromLocation];
	  trip->fromLocation = Nodes_pimpl::LookupNode(value);
}

sim_mob::TripChainItem::LocationType  getLocationType(std::string LocationType)
{
	  sim_mob::TripChainItem::LocationType locationType;
	  if(LocationType == "LT_BUILDING")
		  locationType = sim_mob::TripChainItem::LT_BUILDING;
	  else
		  if(LocationType == "LT_NODE")
			  locationType = sim_mob::TripChainItem::LT_NODE;
		  else
			  if(LocationType == "LT_LINK")
				  locationType = sim_mob::TripChainItem::LT_LINK;
			  else
				  if(LocationType == "LT_PUBLIC_TRANSIT_STOP")
					  locationType = sim_mob::TripChainItem::LT_PUBLIC_TRANSIT_STOP;
	  return locationType;
}
void Trip_t_pimpl::
fromLocationType (std::string fromLocationType)
{
	  if(!trip) return;
	  std::cout << "In Trip_t_pimpl::fromLocationType ()"  << std::endl;
	  trip->fromLocationType = getLocationType(fromLocationType);
	  std::cout << "In Trip_t_pimpl::fromLocationType ()--"  << std::endl;
}

void Trip_t_pimpl::
toLocation (unsigned int value)
{
	  if(!trip) return;
	  std::cout << "In Trip_t_pimpl::toLocation ()"  << std::endl;
	  trip->toLocation = Nodes_pimpl::LookupNode(value);
}

void Trip_t_pimpl::
toLocationType (std::string toLocationType)
{
	  if(!trip) return;
	  std::cout << "In Trip_t_pimpl::toLocationType ()"  << std::endl;
	  trip->toLocationType = getLocationType(toLocationType);
}

void Trip_t_pimpl::
subTrips (std::vector<sim_mob::SubTrip> subTrips)
{
	  if(!trip) return;
	  std::cout << "In Trip_t_pimpl::subTrips ()"  << std::endl;
	  trip->setSubTrips(subTrips);
}

sim_mob::TripChainItem* Trip_t_pimpl::
post_Trip_t ()
{
	  if(!trip) return 0;
	  std::cout << "In Trip_t_pimpl::post_Trip_t ()"  << std::endl;
   sim_mob::TripChainItem* v = post_TripChainItem_t ();
	if (v) {
		trip->personID = v->personID;
		trip->itemType = v->itemType;
		trip->sequenceNumber = v->sequenceNumber;
		trip->startTime = v->startTime;
		trip->endTime = v->endTime;
		delete v;
	}
	//nullify the local variable just in case
	sim_mob::Trip *temp_trip = 0;
	temp_trip = trip;
	trip = 0;
	//now deliver the cookout
   return temp_trip;
}

// SubTrip_t_pimpl
//

void SubTrip_t_pimpl::
pre ()
{
	  subTrip.tripID = 0;
	  subTrip.fromLocation = 0;
	  subTrip.toLocation = 0;
	  subTrip.mode = "";
	  subTrip.isPrimaryMode = false;
	  subTrip.ptLineId = "";
}

void SubTrip_t_pimpl::
mode (const ::std::string& mode)
{
	  subTrip.mode = mode;
}

void SubTrip_t_pimpl::
isPrimaryMode (bool isPrimaryMode)
{
	  subTrip.isPrimaryMode = isPrimaryMode;
}

void SubTrip_t_pimpl::
ptLineId (const ::std::string& ptLineId)
{
	  subTrip.ptLineId = ptLineId;
}

sim_mob::SubTrip SubTrip_t_pimpl::
post_SubTrip_t ()
{
		sim_mob::TripChainItem* v (post_Trip_t ());
	if (v) {
		sim_mob::Trip *trip = dynamic_cast<sim_mob::Trip *>(v);
		subTrip.personID = trip->personID;
		//TODO:the following three items( which are inherited from trip)
		//may need to be initialized differently
		//for now, I keet the same value as their parent(trip)
		//and we will modify them as and when needed-vahid
		subTrip.startTime = trip->startTime;
		subTrip.endTime = trip->endTime;
		subTrip.sequenceNumber = trip->sequenceNumber;
		////////////////////////////////////////////////
		subTrip.tripID = trip->tripID;
		subTrip.fromLocation = trip->fromLocation;
		subTrip.toLocation = trip->toLocation;
		subTrip.fromLocationType = trip->fromLocationType;
		subTrip.toLocationType = trip->toLocationType;
		delete trip;
	}
	  	return subTrip;
}

// SubTrips_t_pimpl
//

void SubTrips_t_pimpl::
pre ()
{
	  subTrips.clear();
}

void SubTrips_t_pimpl::
subTrip (sim_mob::SubTrip subTrip)
{
	  subTrips.push_back(subTrip);
}

std::vector<sim_mob::SubTrip> SubTrips_t_pimpl::
post_SubTrips_t ()
{
  return subTrips;
}

// Activity_t_pimpl
//

void Activity_t_pimpl::
pre ()
{
	  activity = new sim_mob::Activity();
}

void Activity_t_pimpl::
description (const ::std::string& description)
{
  std::cout << "description: " << description << std::endl;
  activity->description = description;
}

void Activity_t_pimpl::
location (unsigned int value)
{
	  activity->location = Nodes_pimpl::LookupNode(value);
}

void Activity_t_pimpl::
locationType (std::string locationType)
{

		  activity->locationType = getLocationType(locationType);
}

void Activity_t_pimpl::
isPrimary (bool isPrimary)
{
  activity->isPrimary = isPrimary;
}

void Activity_t_pimpl::
isFlexible (bool isFlexible)
{
	  activity->isFlexible = isFlexible;
}

void Activity_t_pimpl::
isMandatory (bool isMandatory)
{
	  activity->isMandatory = isMandatory;
}

sim_mob::TripChainItem* Activity_t_pimpl::
post_Activity_t ()
{
  sim_mob::TripChainItem* v = post_TripChainItem_t ();
  activity->personID = v->personID;
  activity->itemType = v->itemType;
  activity->sequenceNumber = v->sequenceNumber;
  activity->startTime = v->startTime;
  activity->endTime = v->endTime;
  delete v;
  return activity;
}

// TripChain_t_pimpl
//

void TripChain_t_pimpl::
pre ()
{
	  std::cout << "in TripChain_t_pimpl::pre () "  ;
	  personID_Tripchain_Pair.first = -1;
	  personID_Tripchain_Pair.second.clear();
}

void TripChain_t_pimpl::
personID (long long personID)
{
	  std::cout << "in TripChain_t_pimpl::personID() " << std::endl ;

	  personID_Tripchain_Pair.first = personID;

	  std::cout << "in TripChain_t_pimpl::personID()-- " << std::endl ;
}

void TripChain_t_pimpl::
Trip (sim_mob::TripChainItem* Trip)
{
	  std::cout << "in TripChain_t_pimpl::Trip "  ;

	  personID_Tripchain_Pair.second.push_back(Trip);
}

void TripChain_t_pimpl::
Activity (sim_mob::TripChainItem* Activity)
{
	  std::cout << "in TripChain_t_pimpl::Activity "  ;
	  personID_Tripchain_Pair.second.push_back(Activity);
}

std::pair<unsigned long, std::vector<sim_mob::TripChainItem*> > TripChain_t_pimpl::
post_TripChain_t ()
{
	  std::cout << "posting trip chain for person " << personID_Tripchain_Pair.first << std::endl ;
	  return personID_Tripchain_Pair;
}

// TripChains_t_pimpl
//

void TripChains_t_pimpl::
pre ()
{
	  std::cout << "In TripChains_t_pimpl::pre ()\n";
	 tripchains = sim_mob::ConfigParams::GetInstance().getTripChains();
	 std::cout << "In TripChains_t_pimpl::pre ()--\n";

}

void TripChains_t_pimpl::
TripChain (std::pair<unsigned long, std::vector<sim_mob::TripChainItem*> > TripChain)
{
	  std::cout << "In TripChains_t_pimpl::TripChain ()...\n";
	  sim_mob::ConfigParams::GetInstance().getTripChains()[TripChain.first] = (TripChain.second);
	  std::cout << "A trip was added to person " <<  TripChain.first << "[new size = " << sim_mob::ConfigParams::GetInstance().getTripChains()[TripChain.first].size() << "]   Total: " << sim_mob::ConfigParams::GetInstance().getTripChains().size();
}

void TripChains_t_pimpl::
post_TripChains_t ()
{


	  std::cout << "In TripChains_t_pimpl::post_TripChains_t ()\n";

}

// linkAndCrossing_t_pimpl
//

void linkAndCrossing_t_pimpl::
pre ()
{
}

void linkAndCrossing_t_pimpl::
ID (unsigned char ID)
{
  std::cout << "ID: " << static_cast<unsigned short> (ID) << std::endl;
  LAC.id = ID;
}

void linkAndCrossing_t_pimpl::
linkID (unsigned int linkID)
{
  std::cout << "linkID: " << linkID << std::endl;
  LAC.link = geo_Links_[linkID];
}

void linkAndCrossing_t_pimpl::
crossingID (unsigned int crossingID)
{
  std::cout << "crossingID: " << crossingID << std::endl;
//    LAC.crossing = geo_c
}

void linkAndCrossing_t_pimpl::
angle (unsigned char angle)
{
  std::cout << "angle: " << static_cast<unsigned short> (angle) << std::endl;
}

sim_mob::LinkAndCrossing linkAndCrossing_t_pimpl::
post_linkAndCrossing_t ()
{
  // TODO
  //
  // return ... ;
}

// linkAndCrossings_t_pimpl
//

void linkAndCrossings_t_pimpl::
pre ()
{
}

void linkAndCrossings_t_pimpl::
linkAndCrossing (sim_mob::LinkAndCrossing linkAndCrossing)
{
  // TODO
  //
}

sim_mob::LinkAndCrossingC linkAndCrossings_t_pimpl::
post_linkAndCrossings_t ()
{
  // TODO
  //
  // return ... ;
}

// signalAlgorithm_t_pimpl
//

void signalAlgorithm_t_pimpl::
pre ()
{
}

void signalAlgorithm_t_pimpl::
post_signalAlgorithm_t ()
{
  const ::std::string& v (post_string ());

  std::cout << "signalAlgorithm_t: " << v << std::endl;
}

// Plan_t_pimpl
//

void Plan_t_pimpl::
pre ()
{
}

void Plan_t_pimpl::
planID (unsigned char planID)
{
  std::cout << "planID: " << static_cast<unsigned short> (planID) << std::endl;
}

void Plan_t_pimpl::
PhasePercentage (double PhasePercentage)
{
  std::cout << "PhasePercentage: " << PhasePercentage << std::endl;
}

void Plan_t_pimpl::
post_Plan_t ()
{
}

// Plans_t_pimpl
//

void Plans_t_pimpl::
pre ()
{
}

void Plans_t_pimpl::
Plan ()
{
}

void Plans_t_pimpl::
post_Plans_t ()
{
}

// TrafficColor_t_pimpl
//

void TrafficColor_t_pimpl::
pre ()
{
}

void TrafficColor_t_pimpl::
post_TrafficColor_t ()
{
  const ::std::string& v (post_string ());

  std::cout << "TrafficColor_t: " << v << std::endl;
}

// ColorDuration_t_pimpl
//

void ColorDuration_t_pimpl::
pre ()
{
}

void ColorDuration_t_pimpl::
TrafficColor ()
{
}

void ColorDuration_t_pimpl::
Duration (unsigned char Duration)
{
  std::cout << "Duration: " << static_cast<unsigned short> (Duration) << std::endl;
}

std::pair<sim_mob::TrafficColor,std::size_t> ColorDuration_t_pimpl::
post_ColorDuration_t ()
{
  // TODO
  //
  // return ... ;
}

// ColorSequence_t_pimpl
//

void ColorSequence_t_pimpl::
pre ()
{
}

void ColorSequence_t_pimpl::
TrafficLightType (const ::std::string& TrafficLightType)
{
  std::cout << "TrafficLightType: " << TrafficLightType << std::endl;
}

void ColorSequence_t_pimpl::
ColorDuration (std::pair<sim_mob::TrafficColor,std::size_t> ColorDuration)
{
  // TODO
  //
}

std::pair<std::string,std::vector<std::pair<TrafficColor,std::size_t> > > ColorSequence_t_pimpl::
post_ColorSequence_t ()
{
  // TODO
  //
  // return ... ;
}

// links_maps_t_pimpl
//

void links_maps_t_pimpl::
pre ()
{
}

void links_maps_t_pimpl::
links_map (std::pair<sim_mob::Link*,sim_mob::linkToLink> links_map)
{
  // TODO
  //
}

std::multimap<sim_mob::Link*,sim_mob::linkToLink> links_maps_t_pimpl::
post_links_maps_t ()
{
  // TODO
  //
  // return ... ;
}

// links_map_t_pimpl
//

void links_map_t_pimpl::
pre ()
{
}

void links_map_t_pimpl::
linkFrom (unsigned int linkFrom)
{
  std::cout << "linkFrom: " << linkFrom << std::endl;
}

void links_map_t_pimpl::
linkTo (unsigned int linkTo)
{
  std::cout << "linkTo: " << linkTo << std::endl;
}

void links_map_t_pimpl::
SegmentFrom (unsigned int SegmentFrom)
{
  std::cout << "SegmentFrom: " << SegmentFrom << std::endl;
}

void links_map_t_pimpl::
SegmentTo (unsigned int SegmentTo)
{
  std::cout << "SegmentTo: " << SegmentTo << std::endl;
}

void links_map_t_pimpl::
ColorSequence (std::pair<std::string,std::vector<std::pair<TrafficColor,std::size_t> > > ColorSequence)
{
  // TODO
  //
}

std::pair<sim_mob::Link*,sim_mob::linkToLink> links_map_t_pimpl::
post_links_map_t ()
{
  // TODO
  //
  // return ... ;
}

// Phase_t_pimpl
//

void Phase_t_pimpl::
pre ()
{
}

void Phase_t_pimpl::
phaseID (unsigned char phaseID)
{
  std::cout << "phaseID: " << static_cast<unsigned short> (phaseID) << std::endl;
}

void Phase_t_pimpl::
name (const ::std::string& name)
{
  std::cout << "name: " << name << std::endl;
}

void Phase_t_pimpl::
links_map (std::multimap<sim_mob::Link*,sim_mob::linkToLink> links_map)
{
  // TODO
  //
}

void Phase_t_pimpl::
post_Phase_t ()
{
}

// Phases_t_pimpl
//

void Phases_t_pimpl::
pre ()
{
}

void Phases_t_pimpl::
Phase ()
{
}

void Phases_t_pimpl::
post_Phases_t ()
{
}

// SplitPlan_t_pimpl
//

void SplitPlan_t_pimpl::
pre ()
{
}

void SplitPlan_t_pimpl::
splitplanID (unsigned int splitplanID)
{
  std::cout << "splitplanID: " << splitplanID << std::endl;
}

void SplitPlan_t_pimpl::
signalAlgorithm ()
{
}

void SplitPlan_t_pimpl::
cycleLength (unsigned char cycleLength)
{
  std::cout << "cycleLength: " << static_cast<unsigned short> (cycleLength) << std::endl;
}

void SplitPlan_t_pimpl::
offset (unsigned char offset)
{
  std::cout << "offset: " << static_cast<unsigned short> (offset) << std::endl;
}

void SplitPlan_t_pimpl::
ChoiceSet ()
{
}

void SplitPlan_t_pimpl::
Phases ()
{
}

sim_mob::SplitPlan SplitPlan_t_pimpl::
post_SplitPlan_t ()
{
  // TODO
  //
  // return ... ;
}

// Signal_t_pimpl
//

void Signal_t_pimpl::
pre ()
{
}

void Signal_t_pimpl::
signalID (unsigned char signalID)
{
  std::cout << "signalID: " << static_cast<unsigned short> (signalID) << std::endl;
}

void Signal_t_pimpl::
nodeID (unsigned int nodeID)
{
  std::cout << "nodeID: " << nodeID << std::endl;
}

void Signal_t_pimpl::
signalAlgorithm ()
{
}

void Signal_t_pimpl::
linkAndCrossings (sim_mob::LinkAndCrossingC linkAndCrossings)
{
  // TODO
  //
}

void Signal_t_pimpl::
SplitPlan (sim_mob::SplitPlan SplitPlan)
{
  // TODO
  //
}

sim_mob::Signal* Signal_t_pimpl::
post_Signal_t ()
{
  // TODO
  //
  // return ... ;
}

// Signals_t_pimpl
//

void Signals_t_pimpl::
pre ()
{
}

void Signals_t_pimpl::
signal (sim_mob::Signal* signal)
{
  // TODO
  //
}

void Signals_t_pimpl::
post_Signals_t ()
{
}

// GeoSpatial_t_pimpl
//



// SimMobility_t_pimpl
//

void SimMobility_t_pimpl::
pre ()
{
	  std::cout << "In SimMobility_t_pimpl.pre()\n";
}

void SimMobility_t_pimpl::
GeoSpatial ()
{
	  std::cout << "In SimMobility_t_pimpl::sim_mob::xmlSpatial ()--Do Nothing\n";
}

void SimMobility_t_pimpl::
TripChains ()
{
	  std::cout << "In SimMobility_t_pimpl::TripChains ()--Do Nothing\n";
}

void SimMobility_t_pimpl::
Signals ()
{
  // TODO
  //
}

void SimMobility_t_pimpl::
post_SimMobility_t ()
{
	  std::cout << "In SimMobility_t_pimpl::post_SimMobility_t ()--Do Nothing\n";
}

// Lanes_pimpl
//



// Segments_pimpl
//

void Segments_pimpl::
pre ()
{
	  fwd.clear();
	  bck.clear();
}

void Segments_pimpl::
FWDSegments (std::vector<sim_mob::RoadSegment*> FWDSegments)
{
	  fwd = FWDSegments;
}

void Segments_pimpl::
BKDSegments (std::vector<sim_mob::RoadSegment*> BKDSegments)
{
	  bck = BKDSegments;

}

std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> > Segments_pimpl::
post_Segments ()
{
	  return (std::make_pair(fwd,bck));
}

// Nodes_pimpl
//



// Links_pimpl
//


// UniNodes_pimpl
//

void UniNodes_pimpl::
pre ()
{
	  std::cout << "UniNodes_pimpl::pre()\n";
}

void UniNodes_pimpl::
UniNode (sim_mob::UniNode* UniNode)
{
	  uniNodes.insert(UniNode);
}

std::set<sim_mob::UniNode*>& UniNodes_pimpl::
post_UniNodes ()
{
	  std::cout << "UniNodes_pimpl::post_UniNodes()\n";
	  return uniNodes;
}

// Intersections_pimpl
//

void Intersections_pimpl::
pre ()
{
//	  std::cout << "Intersections_pimpl::pre()\n";
}

void Intersections_pimpl::
Intersection (sim_mob::MultiNode* Intersection)
{
	  intersections.push_back(Intersection);
}

std::vector<sim_mob::MultiNode*>& Intersections_pimpl::
post_Intersections ()
{
	  return intersections;
}

// roundabouts_pimpl
//

void roundabouts_pimpl::
pre ()
{
	//MultiNode_t_pimpl::pre();
}

void roundabouts_pimpl::
roundabout (sim_mob::MultiNode* roundabout)
{
	  roundabouts.push_back(roundabout);
  // TODO
  //
}

std::vector<sim_mob::MultiNode*>& roundabouts_pimpl::
post_roundabouts ()
{
	  return roundabouts;
}

}} //End namespace sim_mob::xml

