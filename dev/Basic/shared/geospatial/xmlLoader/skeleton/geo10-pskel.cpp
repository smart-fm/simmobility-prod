// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
// NOTE: Do *not* edit the -pskel.* files; they are generated automatically from the xsd file. 
//       Instead, modify the -pimpl.* files. ~Seth
//
// End prologue.

#include "geo10-pskel.hpp"

namespace sim_mob
{
  namespace xml
  {
    // Point2D_t_pskel
    //

    void Point2D_t_pskel::
    xPos_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->xPos_parser_ = &p;
    }

    void Point2D_t_pskel::
    yPos_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->yPos_parser_ = &p;
    }

    void Point2D_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& xPos,
             ::xml_schema::unsigned_int_pskel& yPos)
    {
      this->xPos_parser_ = &xPos;
      this->yPos_parser_ = &yPos;
    }

    Point2D_t_pskel::
    Point2D_t_pskel ()
    : xPos_parser_ (0),
      yPos_parser_ (0)
    {
    }

    // PolyPoint_t_pskel
    //

    void PolyPoint_t_pskel::
    pointID_parser (::xml_schema::string_pskel& p)
    {
      this->pointID_parser_ = &p;
    }

    void PolyPoint_t_pskel::
    location_parser (::sim_mob::xml::Point2D_t_pskel& p)
    {
      this->location_parser_ = &p;
    }

    void PolyPoint_t_pskel::
    parsers (::xml_schema::string_pskel& pointID,
             ::sim_mob::xml::Point2D_t_pskel& location)
    {
      this->pointID_parser_ = &pointID;
      this->location_parser_ = &location;
    }

    PolyPoint_t_pskel::
    PolyPoint_t_pskel ()
    : pointID_parser_ (0),
      location_parser_ (0)
    {
    }

    // PolyLine_t_pskel
    //

    void PolyLine_t_pskel::
    PolyPoint_parser (::sim_mob::xml::PolyPoint_t_pskel& p)
    {
      this->PolyPoint_parser_ = &p;
    }

    void PolyLine_t_pskel::
    parsers (::sim_mob::xml::PolyPoint_t_pskel& PolyPoint)
    {
      this->PolyPoint_parser_ = &PolyPoint;
    }

    PolyLine_t_pskel::
    PolyLine_t_pskel ()
    : PolyPoint_parser_ (0)
    {
    }

    // lane_t_pskel
    //

    void lane_t_pskel::
    laneID_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->laneID_parser_ = &p;
    }

    void lane_t_pskel::
    width_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->width_parser_ = &p;
    }

    void lane_t_pskel::
    can_go_straight_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_go_straight_parser_ = &p;
    }

    void lane_t_pskel::
    can_turn_left_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_turn_left_parser_ = &p;
    }

    void lane_t_pskel::
    can_turn_right_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_turn_right_parser_ = &p;
    }

    void lane_t_pskel::
    can_turn_on_red_signal_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_turn_on_red_signal_parser_ = &p;
    }

    void lane_t_pskel::
    can_change_lane_left_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_change_lane_left_parser_ = &p;
    }

    void lane_t_pskel::
    can_change_lane_right_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_change_lane_right_parser_ = &p;
    }

    void lane_t_pskel::
    is_road_shoulder_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_road_shoulder_parser_ = &p;
    }

    void lane_t_pskel::
    is_bicycle_lane_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_bicycle_lane_parser_ = &p;
    }

    void lane_t_pskel::
    is_pedestrian_lane_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_pedestrian_lane_parser_ = &p;
    }

    void lane_t_pskel::
    is_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_vehicle_lane_parser_ = &p;
    }

    void lane_t_pskel::
    is_standard_bus_lane_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_standard_bus_lane_parser_ = &p;
    }

    void lane_t_pskel::
    is_whole_day_bus_lane_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_whole_day_bus_lane_parser_ = &p;
    }

    void lane_t_pskel::
    is_high_occupancy_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_high_occupancy_vehicle_lane_parser_ = &p;
    }

    void lane_t_pskel::
    can_freely_park_here_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_freely_park_here_parser_ = &p;
    }

    void lane_t_pskel::
    can_stop_here_parser (::xml_schema::boolean_pskel& p)
    {
      this->can_stop_here_parser_ = &p;
    }

    void lane_t_pskel::
    is_u_turn_allowed_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_u_turn_allowed_parser_ = &p;
    }

    void lane_t_pskel::
    PolyLine_parser (::sim_mob::xml::PolyLine_t_pskel& p)
    {
      this->PolyLine_parser_ = &p;
    }

    void lane_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& laneID,
             ::xml_schema::unsigned_int_pskel& width,
             ::xml_schema::boolean_pskel& can_go_straight,
             ::xml_schema::boolean_pskel& can_turn_left,
             ::xml_schema::boolean_pskel& can_turn_right,
             ::xml_schema::boolean_pskel& can_turn_on_red_signal,
             ::xml_schema::boolean_pskel& can_change_lane_left,
             ::xml_schema::boolean_pskel& can_change_lane_right,
             ::xml_schema::boolean_pskel& is_road_shoulder,
             ::xml_schema::boolean_pskel& is_bicycle_lane,
             ::xml_schema::boolean_pskel& is_pedestrian_lane,
             ::xml_schema::boolean_pskel& is_vehicle_lane,
             ::xml_schema::boolean_pskel& is_standard_bus_lane,
             ::xml_schema::boolean_pskel& is_whole_day_bus_lane,
             ::xml_schema::boolean_pskel& is_high_occupancy_vehicle_lane,
             ::xml_schema::boolean_pskel& can_freely_park_here,
             ::xml_schema::boolean_pskel& can_stop_here,
             ::xml_schema::boolean_pskel& is_u_turn_allowed,
             ::sim_mob::xml::PolyLine_t_pskel& PolyLine)
    {
      this->laneID_parser_ = &laneID;
      this->width_parser_ = &width;
      this->can_go_straight_parser_ = &can_go_straight;
      this->can_turn_left_parser_ = &can_turn_left;
      this->can_turn_right_parser_ = &can_turn_right;
      this->can_turn_on_red_signal_parser_ = &can_turn_on_red_signal;
      this->can_change_lane_left_parser_ = &can_change_lane_left;
      this->can_change_lane_right_parser_ = &can_change_lane_right;
      this->is_road_shoulder_parser_ = &is_road_shoulder;
      this->is_bicycle_lane_parser_ = &is_bicycle_lane;
      this->is_pedestrian_lane_parser_ = &is_pedestrian_lane;
      this->is_vehicle_lane_parser_ = &is_vehicle_lane;
      this->is_standard_bus_lane_parser_ = &is_standard_bus_lane;
      this->is_whole_day_bus_lane_parser_ = &is_whole_day_bus_lane;
      this->is_high_occupancy_vehicle_lane_parser_ = &is_high_occupancy_vehicle_lane;
      this->can_freely_park_here_parser_ = &can_freely_park_here;
      this->can_stop_here_parser_ = &can_stop_here;
      this->is_u_turn_allowed_parser_ = &is_u_turn_allowed;
      this->PolyLine_parser_ = &PolyLine;
    }

    lane_t_pskel::
    lane_t_pskel ()
    : laneID_parser_ (0),
      width_parser_ (0),
      can_go_straight_parser_ (0),
      can_turn_left_parser_ (0),
      can_turn_right_parser_ (0),
      can_turn_on_red_signal_parser_ (0),
      can_change_lane_left_parser_ (0),
      can_change_lane_right_parser_ (0),
      is_road_shoulder_parser_ (0),
      is_bicycle_lane_parser_ (0),
      is_pedestrian_lane_parser_ (0),
      is_vehicle_lane_parser_ (0),
      is_standard_bus_lane_parser_ (0),
      is_whole_day_bus_lane_parser_ (0),
      is_high_occupancy_vehicle_lane_parser_ (0),
      can_freely_park_here_parser_ (0),
      can_stop_here_parser_ (0),
      is_u_turn_allowed_parser_ (0),
      PolyLine_parser_ (0)
    {
    }

    // connector_t_pskel
    //

    void connector_t_pskel::
    laneFrom_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->laneFrom_parser_ = &p;
    }

    void connector_t_pskel::
    laneTo_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->laneTo_parser_ = &p;
    }

    void connector_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& laneFrom,
             ::xml_schema::unsigned_long_pskel& laneTo)
    {
      this->laneFrom_parser_ = &laneFrom;
      this->laneTo_parser_ = &laneTo;
    }

    connector_t_pskel::
    connector_t_pskel ()
    : laneFrom_parser_ (0),
      laneTo_parser_ (0)
    {
    }

    // connectors_t_pskel
    //

    void connectors_t_pskel::
    Connector_parser (::sim_mob::xml::connector_t_pskel& p)
    {
      this->Connector_parser_ = &p;
    }

    void connectors_t_pskel::
    parsers (::sim_mob::xml::connector_t_pskel& Connector)
    {
      this->Connector_parser_ = &Connector;
    }

    connectors_t_pskel::
    connectors_t_pskel ()
    : Connector_parser_ (0)
    {
    }

    // Multi_Connector_t_pskel
    //

    void Multi_Connector_t_pskel::
    RoadSegment_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->RoadSegment_parser_ = &p;
    }

    void Multi_Connector_t_pskel::
    Connectors_parser (::sim_mob::xml::connectors_t_pskel& p)
    {
      this->Connectors_parser_ = &p;
    }

    void Multi_Connector_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& RoadSegment,
             ::sim_mob::xml::connectors_t_pskel& Connectors)
    {
      this->RoadSegment_parser_ = &RoadSegment;
      this->Connectors_parser_ = &Connectors;
    }

    Multi_Connector_t_pskel::
    Multi_Connector_t_pskel ()
    : RoadSegment_parser_ (0),
      Connectors_parser_ (0)
    {
    }

    // Multi_Connectors_t_pskel
    //

    void Multi_Connectors_t_pskel::
    MultiConnectors_parser (::sim_mob::xml::Multi_Connector_t_pskel& p)
    {
      this->MultiConnectors_parser_ = &p;
    }

    void Multi_Connectors_t_pskel::
    parsers (::sim_mob::xml::Multi_Connector_t_pskel& MultiConnectors)
    {
      this->MultiConnectors_parser_ = &MultiConnectors;
    }

    Multi_Connectors_t_pskel::
    Multi_Connectors_t_pskel ()
    : MultiConnectors_parser_ (0)
    {
    }

    // fwdBckSegments_t_pskel
    //

    void fwdBckSegments_t_pskel::
    Segment_parser (::sim_mob::xml::segment_t_pskel& p)
    {
      this->Segment_parser_ = &p;
    }

    void fwdBckSegments_t_pskel::
    parsers (::sim_mob::xml::segment_t_pskel& Segment)
    {
      this->Segment_parser_ = &Segment;
    }

    fwdBckSegments_t_pskel::
    fwdBckSegments_t_pskel ()
    : Segment_parser_ (0)
    {
    }

    // RoadSegmentsAt_t_pskel
    //

    void RoadSegmentsAt_t_pskel::
    segmentID_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->segmentID_parser_ = &p;
    }

    void RoadSegmentsAt_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& segmentID)
    {
      this->segmentID_parser_ = &segmentID;
    }

    RoadSegmentsAt_t_pskel::
    RoadSegmentsAt_t_pskel ()
    : segmentID_parser_ (0)
    {
    }

    // laneEdgePolyline_cached_t_pskel
    //

    void laneEdgePolyline_cached_t_pskel::
    laneNumber_parser (::xml_schema::short_pskel& p)
    {
      this->laneNumber_parser_ = &p;
    }

    void laneEdgePolyline_cached_t_pskel::
    polyline_parser (::sim_mob::xml::PolyLine_t_pskel& p)
    {
      this->polyline_parser_ = &p;
    }

    void laneEdgePolyline_cached_t_pskel::
    parsers (::xml_schema::short_pskel& laneNumber,
             ::sim_mob::xml::PolyLine_t_pskel& polyline)
    {
      this->laneNumber_parser_ = &laneNumber;
      this->polyline_parser_ = &polyline;
    }

    laneEdgePolyline_cached_t_pskel::
    laneEdgePolyline_cached_t_pskel ()
    : laneNumber_parser_ (0),
      polyline_parser_ (0)
    {
    }

    // laneEdgePolylines_cached_t_pskel
    //

    void laneEdgePolylines_cached_t_pskel::
    laneEdgePolyline_cached_parser (::sim_mob::xml::laneEdgePolyline_cached_t_pskel& p)
    {
      this->laneEdgePolyline_cached_parser_ = &p;
    }

    void laneEdgePolylines_cached_t_pskel::
    parsers (::sim_mob::xml::laneEdgePolyline_cached_t_pskel& laneEdgePolyline_cached)
    {
      this->laneEdgePolyline_cached_parser_ = &laneEdgePolyline_cached;
    }

    laneEdgePolylines_cached_t_pskel::
    laneEdgePolylines_cached_t_pskel ()
    : laneEdgePolyline_cached_parser_ (0)
    {
    }

    // segment_t_pskel
    //

    void segment_t_pskel::
    segmentID_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->segmentID_parser_ = &p;
    }

    void segment_t_pskel::
    startingNode_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->startingNode_parser_ = &p;
    }

    void segment_t_pskel::
    endingNode_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->endingNode_parser_ = &p;
    }

    void segment_t_pskel::
    maxSpeed_parser (::xml_schema::short_pskel& p)
    {
      this->maxSpeed_parser_ = &p;
    }

    void segment_t_pskel::
    Length_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->Length_parser_ = &p;
    }

    void segment_t_pskel::
    Width_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->Width_parser_ = &p;
    }

    void segment_t_pskel::
    originalDB_ID_parser (::xml_schema::string_pskel& p)
    {
      this->originalDB_ID_parser_ = &p;
    }

    void segment_t_pskel::
    polyline_parser (::sim_mob::xml::PolyLine_t_pskel& p)
    {
      this->polyline_parser_ = &p;
    }

    void segment_t_pskel::
    laneEdgePolylines_cached_parser (::sim_mob::xml::laneEdgePolylines_cached_t_pskel& p)
    {
      this->laneEdgePolylines_cached_parser_ = &p;
    }

    void segment_t_pskel::
    Lanes_parser (::sim_mob::xml::Lanes_pskel& p)
    {
      this->Lanes_parser_ = &p;
    }

    void segment_t_pskel::
    Obstacles_parser (::sim_mob::xml::RoadItems_t_pskel& p)
    {
      this->Obstacles_parser_ = &p;
    }

    void segment_t_pskel::
    KurbLine_parser (::sim_mob::xml::PolyLine_t_pskel& p)
    {
      this->KurbLine_parser_ = &p;
    }

    void segment_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& segmentID,
             ::xml_schema::unsigned_int_pskel& startingNode,
             ::xml_schema::unsigned_int_pskel& endingNode,
             ::xml_schema::short_pskel& maxSpeed,
             ::xml_schema::unsigned_int_pskel& Length,
             ::xml_schema::unsigned_int_pskel& Width,
             ::xml_schema::string_pskel& originalDB_ID,
             ::sim_mob::xml::PolyLine_t_pskel& polyline,
             ::sim_mob::xml::laneEdgePolylines_cached_t_pskel& laneEdgePolylines_cached,
             ::sim_mob::xml::Lanes_pskel& Lanes,
             ::sim_mob::xml::RoadItems_t_pskel& Obstacles,
             ::sim_mob::xml::PolyLine_t_pskel& KurbLine)
    {
      this->segmentID_parser_ = &segmentID;
      this->startingNode_parser_ = &startingNode;
      this->endingNode_parser_ = &endingNode;
      this->maxSpeed_parser_ = &maxSpeed;
      this->Length_parser_ = &Length;
      this->Width_parser_ = &Width;
      this->originalDB_ID_parser_ = &originalDB_ID;
      this->polyline_parser_ = &polyline;
      this->laneEdgePolylines_cached_parser_ = &laneEdgePolylines_cached;
      this->Lanes_parser_ = &Lanes;
      this->Obstacles_parser_ = &Obstacles;
      this->KurbLine_parser_ = &KurbLine;
    }

    segment_t_pskel::
    segment_t_pskel ()
    : segmentID_parser_ (0),
      startingNode_parser_ (0),
      endingNode_parser_ (0),
      maxSpeed_parser_ (0),
      Length_parser_ (0),
      Width_parser_ (0),
      originalDB_ID_parser_ (0),
      polyline_parser_ (0),
      laneEdgePolylines_cached_parser_ (0),
      Lanes_parser_ (0),
      Obstacles_parser_ (0),
      KurbLine_parser_ (0)
    {
    }

    // link_t_pskel
    //

    void link_t_pskel::
    linkID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->linkID_parser_ = &p;
    }

    void link_t_pskel::
    roadName_parser (::xml_schema::string_pskel& p)
    {
      this->roadName_parser_ = &p;
    }

    void link_t_pskel::
    StartingNode_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->StartingNode_parser_ = &p;
    }

    void link_t_pskel::
    EndingNode_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->EndingNode_parser_ = &p;
    }

    void link_t_pskel::
    Segments_parser (::sim_mob::xml::fwdBckSegments_t_pskel& p)
    {
      this->Segments_parser_ = &p;
    }

    void link_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& linkID,
             ::xml_schema::string_pskel& roadName,
             ::xml_schema::unsigned_int_pskel& StartingNode,
             ::xml_schema::unsigned_int_pskel& EndingNode,
             ::sim_mob::xml::fwdBckSegments_t_pskel& Segments)
    {
      this->linkID_parser_ = &linkID;
      this->roadName_parser_ = &roadName;
      this->StartingNode_parser_ = &StartingNode;
      this->EndingNode_parser_ = &EndingNode;
      this->Segments_parser_ = &Segments;
    }

    link_t_pskel::
    link_t_pskel ()
    : linkID_parser_ (0),
      roadName_parser_ (0),
      StartingNode_parser_ (0),
      EndingNode_parser_ (0),
      Segments_parser_ (0)
    {
    }

    // separator_t_pskel
    //

    void separator_t_pskel::
    separator_ID_parser (::xml_schema::unsigned_short_pskel& p)
    {
      this->separator_ID_parser_ = &p;
    }

    void separator_t_pskel::
    separator_value_parser (::xml_schema::boolean_pskel& p)
    {
      this->separator_value_parser_ = &p;
    }

    void separator_t_pskel::
    parsers (::xml_schema::unsigned_short_pskel& separator_ID,
             ::xml_schema::boolean_pskel& separator_value)
    {
      this->separator_ID_parser_ = &separator_ID;
      this->separator_value_parser_ = &separator_value;
    }

    separator_t_pskel::
    separator_t_pskel ()
    : separator_ID_parser_ (0),
      separator_value_parser_ (0)
    {
    }

    // separators_t_pskel
    //

    void separators_t_pskel::
    Separator_parser (::sim_mob::xml::separator_t_pskel& p)
    {
      this->Separator_parser_ = &p;
    }

    void separators_t_pskel::
    parsers (::sim_mob::xml::separator_t_pskel& Separator)
    {
      this->Separator_parser_ = &Separator;
    }

    separators_t_pskel::
    separators_t_pskel ()
    : Separator_parser_ (0)
    {
    }

    // DomainIsland_t_pskel
    //

    void DomainIsland_t_pskel::
    domainIsland_ID_parser (::xml_schema::unsigned_short_pskel& p)
    {
      this->domainIsland_ID_parser_ = &p;
    }

    void DomainIsland_t_pskel::
    domainIsland_value_parser (::xml_schema::boolean_pskel& p)
    {
      this->domainIsland_value_parser_ = &p;
    }

    void DomainIsland_t_pskel::
    parsers (::xml_schema::unsigned_short_pskel& domainIsland_ID,
             ::xml_schema::boolean_pskel& domainIsland_value)
    {
      this->domainIsland_ID_parser_ = &domainIsland_ID;
      this->domainIsland_value_parser_ = &domainIsland_value;
    }

    DomainIsland_t_pskel::
    DomainIsland_t_pskel ()
    : domainIsland_ID_parser_ (0),
      domainIsland_value_parser_ (0)
    {
    }

    // DomainIslands_t_pskel
    //

    void DomainIslands_t_pskel::
    domainIslands_parser (::sim_mob::xml::DomainIsland_t_pskel& p)
    {
      this->domainIslands_parser_ = &p;
    }

    void DomainIslands_t_pskel::
    parsers (::sim_mob::xml::DomainIsland_t_pskel& domainIslands)
    {
      this->domainIslands_parser_ = &domainIslands;
    }

    DomainIslands_t_pskel::
    DomainIslands_t_pskel ()
    : domainIslands_parser_ (0)
    {
    }

    // offset_t_pskel
    //

    void offset_t_pskel::
    offset_ID_parser (::xml_schema::unsigned_short_pskel& p)
    {
      this->offset_ID_parser_ = &p;
    }

    void offset_t_pskel::
    offset_value_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->offset_value_parser_ = &p;
    }

    void offset_t_pskel::
    parsers (::xml_schema::unsigned_short_pskel& offset_ID,
             ::xml_schema::unsigned_int_pskel& offset_value)
    {
      this->offset_ID_parser_ = &offset_ID;
      this->offset_value_parser_ = &offset_value;
    }

    offset_t_pskel::
    offset_t_pskel ()
    : offset_ID_parser_ (0),
      offset_value_parser_ (0)
    {
    }

    // offsets_t_pskel
    //

    void offsets_t_pskel::
    offset_parser (::sim_mob::xml::offset_t_pskel& p)
    {
      this->offset_parser_ = &p;
    }

    void offsets_t_pskel::
    parsers (::sim_mob::xml::offset_t_pskel& offset)
    {
      this->offset_parser_ = &offset;
    }

    offsets_t_pskel::
    offsets_t_pskel ()
    : offset_parser_ (0)
    {
    }

    // ChunkLength_t_pskel
    //

    void ChunkLength_t_pskel::
    chunklength_ID_parser (::xml_schema::unsigned_short_pskel& p)
    {
      this->chunklength_ID_parser_ = &p;
    }

    void ChunkLength_t_pskel::
    chunklength_value_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->chunklength_value_parser_ = &p;
    }

    void ChunkLength_t_pskel::
    parsers (::xml_schema::unsigned_short_pskel& chunklength_ID,
             ::xml_schema::unsigned_int_pskel& chunklength_value)
    {
      this->chunklength_ID_parser_ = &chunklength_ID;
      this->chunklength_value_parser_ = &chunklength_value;
    }

    ChunkLength_t_pskel::
    ChunkLength_t_pskel ()
    : chunklength_ID_parser_ (0),
      chunklength_value_parser_ (0)
    {
    }

    // ChunkLengths_t_pskel
    //

    void ChunkLengths_t_pskel::
    chunklength_parser (::sim_mob::xml::ChunkLength_t_pskel& p)
    {
      this->chunklength_parser_ = &p;
    }

    void ChunkLengths_t_pskel::
    parsers (::sim_mob::xml::ChunkLength_t_pskel& chunklength)
    {
      this->chunklength_parser_ = &chunklength;
    }

    ChunkLengths_t_pskel::
    ChunkLengths_t_pskel ()
    : chunklength_parser_ (0)
    {
    }

    // LanesVector_t_pskel
    //

    void LanesVector_t_pskel::
    laneID_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->laneID_parser_ = &p;
    }

    void LanesVector_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& laneID)
    {
      this->laneID_parser_ = &laneID;
    }

    LanesVector_t_pskel::
    LanesVector_t_pskel ()
    : laneID_parser_ (0)
    {
    }

    // EntranceAngle_t_pskel
    //

    void EntranceAngle_t_pskel::
    entranceAngle_ID_parser (::xml_schema::unsigned_short_pskel& p)
    {
      this->entranceAngle_ID_parser_ = &p;
    }

    void EntranceAngle_t_pskel::
    entranceAngle_value_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->entranceAngle_value_parser_ = &p;
    }

    void EntranceAngle_t_pskel::
    parsers (::xml_schema::unsigned_short_pskel& entranceAngle_ID,
             ::xml_schema::unsigned_int_pskel& entranceAngle_value)
    {
      this->entranceAngle_ID_parser_ = &entranceAngle_ID;
      this->entranceAngle_value_parser_ = &entranceAngle_value;
    }

    EntranceAngle_t_pskel::
    EntranceAngle_t_pskel ()
    : entranceAngle_ID_parser_ (0),
      entranceAngle_value_parser_ (0)
    {
    }

    // EntranceAngles_t_pskel
    //

    void EntranceAngles_t_pskel::
    entranceAngle_parser (::sim_mob::xml::EntranceAngle_t_pskel& p)
    {
      this->entranceAngle_parser_ = &p;
    }

    void EntranceAngles_t_pskel::
    parsers (::sim_mob::xml::EntranceAngle_t_pskel& entranceAngle)
    {
      this->entranceAngle_parser_ = &entranceAngle;
    }

    EntranceAngles_t_pskel::
    EntranceAngles_t_pskel ()
    : entranceAngle_parser_ (0)
    {
    }

    // Node_t_pskel
    //

    void Node_t_pskel::
    nodeID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->nodeID_parser_ = &p;
    }

    void Node_t_pskel::
    location_parser (::sim_mob::xml::Point2D_t_pskel& p)
    {
      this->location_parser_ = &p;
    }

    void Node_t_pskel::
    originalDB_ID_parser (::xml_schema::string_pskel& p)
    {
      this->originalDB_ID_parser_ = &p;
    }

    void Node_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& nodeID,
             ::sim_mob::xml::Point2D_t_pskel& location,
             ::xml_schema::string_pskel& originalDB_ID)
    {
      this->nodeID_parser_ = &nodeID;
      this->location_parser_ = &location;
      this->originalDB_ID_parser_ = &originalDB_ID;
    }

    Node_t_pskel::
    Node_t_pskel ()
    : nodeID_parser_ (0),
      location_parser_ (0),
      originalDB_ID_parser_ (0)
    {
    }

    // temp_Segmetair_t_pskel
    //

    void temp_Segmetair_t_pskel::
    first_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->first_parser_ = &p;
    }

    void temp_Segmetair_t_pskel::
    second_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->second_parser_ = &p;
    }

    void temp_Segmetair_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& first,
             ::xml_schema::unsigned_long_pskel& second)
    {
      this->first_parser_ = &first;
      this->second_parser_ = &second;
    }

    temp_Segmetair_t_pskel::
    temp_Segmetair_t_pskel ()
    : first_parser_ (0),
      second_parser_ (0)
    {
    }

    // UniNode_t_pskel
    //

    void UniNode_t_pskel::
    firstPair_parser (::sim_mob::xml::temp_Segmetair_t_pskel& p)
    {
      this->firstPair_parser_ = &p;
    }

    void UniNode_t_pskel::
    secondPair_parser (::sim_mob::xml::temp_Segmetair_t_pskel& p)
    {
      this->secondPair_parser_ = &p;
    }

    void UniNode_t_pskel::
    Connectors_parser (::sim_mob::xml::connectors_t_pskel& p)
    {
      this->Connectors_parser_ = &p;
    }

    void UniNode_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& nodeID,
             ::sim_mob::xml::Point2D_t_pskel& location,
             ::xml_schema::string_pskel& originalDB_ID,
             ::sim_mob::xml::temp_Segmetair_t_pskel& firstPair,
             ::sim_mob::xml::temp_Segmetair_t_pskel& secondPair,
             ::sim_mob::xml::connectors_t_pskel& Connectors)
    {
      this->nodeID_parser_ = &nodeID;
      this->location_parser_ = &location;
      this->originalDB_ID_parser_ = &originalDB_ID;
      this->firstPair_parser_ = &firstPair;
      this->secondPair_parser_ = &secondPair;
      this->Connectors_parser_ = &Connectors;
    }

    UniNode_t_pskel::
    UniNode_t_pskel ()
    : firstPair_parser_ (0),
      secondPair_parser_ (0),
      Connectors_parser_ (0)
    {
    }

    // roundabout_t_pskel
    //

    void roundabout_t_pskel::
    roadSegmentsAt_parser (::sim_mob::xml::RoadSegmentsAt_t_pskel& p)
    {
      this->roadSegmentsAt_parser_ = &p;
    }

    void roundabout_t_pskel::
    Connectors_parser (::sim_mob::xml::Multi_Connectors_t_pskel& p)
    {
      this->Connectors_parser_ = &p;
    }

    void roundabout_t_pskel::
    ChunkLengths_parser (::sim_mob::xml::ChunkLengths_t_pskel& p)
    {
      this->ChunkLengths_parser_ = &p;
    }

    void roundabout_t_pskel::
    Offsets_parser (::sim_mob::xml::offsets_t_pskel& p)
    {
      this->Offsets_parser_ = &p;
    }

    void roundabout_t_pskel::
    Separators_parser (::sim_mob::xml::separators_t_pskel& p)
    {
      this->Separators_parser_ = &p;
    }

    void roundabout_t_pskel::
    addDominantLane_parser (::sim_mob::xml::LanesVector_t_pskel& p)
    {
      this->addDominantLane_parser_ = &p;
    }

    void roundabout_t_pskel::
    roundaboutDominantIslands_parser (::xml_schema::float_pskel& p)
    {
      this->roundaboutDominantIslands_parser_ = &p;
    }

    void roundabout_t_pskel::
    roundaboutNumberOfLanes_parser (::xml_schema::int_pskel& p)
    {
      this->roundaboutNumberOfLanes_parser_ = &p;
    }

    void roundabout_t_pskel::
    entranceAngles_parser (::sim_mob::xml::EntranceAngles_t_pskel& p)
    {
      this->entranceAngles_parser_ = &p;
    }

    void roundabout_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& nodeID,
             ::sim_mob::xml::Point2D_t_pskel& location,
             ::xml_schema::string_pskel& originalDB_ID,
             ::sim_mob::xml::RoadSegmentsAt_t_pskel& roadSegmentsAt,
             ::sim_mob::xml::Multi_Connectors_t_pskel& Connectors,
             ::sim_mob::xml::ChunkLengths_t_pskel& ChunkLengths,
             ::sim_mob::xml::offsets_t_pskel& Offsets,
             ::sim_mob::xml::separators_t_pskel& Separators,
             ::sim_mob::xml::LanesVector_t_pskel& addDominantLane,
             ::xml_schema::float_pskel& roundaboutDominantIslands,
             ::xml_schema::int_pskel& roundaboutNumberOfLanes,
             ::sim_mob::xml::EntranceAngles_t_pskel& entranceAngles)
    {
      this->nodeID_parser_ = &nodeID;
      this->location_parser_ = &location;
      this->originalDB_ID_parser_ = &originalDB_ID;
      this->roadSegmentsAt_parser_ = &roadSegmentsAt;
      this->Connectors_parser_ = &Connectors;
      this->ChunkLengths_parser_ = &ChunkLengths;
      this->Offsets_parser_ = &Offsets;
      this->Separators_parser_ = &Separators;
      this->addDominantLane_parser_ = &addDominantLane;
      this->roundaboutDominantIslands_parser_ = &roundaboutDominantIslands;
      this->roundaboutNumberOfLanes_parser_ = &roundaboutNumberOfLanes;
      this->entranceAngles_parser_ = &entranceAngles;
    }

    roundabout_t_pskel::
    roundabout_t_pskel ()
    : roadSegmentsAt_parser_ (0),
      Connectors_parser_ (0),
      ChunkLengths_parser_ (0),
      Offsets_parser_ (0),
      Separators_parser_ (0),
      addDominantLane_parser_ (0),
      roundaboutDominantIslands_parser_ (0),
      roundaboutNumberOfLanes_parser_ (0),
      entranceAngles_parser_ (0)
    {
    }

    // intersection_t_pskel
    //

    void intersection_t_pskel::
    roadSegmentsAt_parser (::sim_mob::xml::RoadSegmentsAt_t_pskel& p)
    {
      this->roadSegmentsAt_parser_ = &p;
    }

    void intersection_t_pskel::
    Connectors_parser (::sim_mob::xml::Multi_Connectors_t_pskel& p)
    {
      this->Connectors_parser_ = &p;
    }

    void intersection_t_pskel::
    ChunkLengths_parser (::sim_mob::xml::ChunkLengths_t_pskel& p)
    {
      this->ChunkLengths_parser_ = &p;
    }

    void intersection_t_pskel::
    Offsets_parser (::sim_mob::xml::offsets_t_pskel& p)
    {
      this->Offsets_parser_ = &p;
    }

    void intersection_t_pskel::
    Separators_parser (::sim_mob::xml::separators_t_pskel& p)
    {
      this->Separators_parser_ = &p;
    }

    void intersection_t_pskel::
    additionalDominantLanes_parser (::sim_mob::xml::LanesVector_t_pskel& p)
    {
      this->additionalDominantLanes_parser_ = &p;
    }

    void intersection_t_pskel::
    additionalSubdominantLanes_parser (::sim_mob::xml::LanesVector_t_pskel& p)
    {
      this->additionalSubdominantLanes_parser_ = &p;
    }

    void intersection_t_pskel::
    domainIslands_parser (::sim_mob::xml::DomainIslands_t_pskel& p)
    {
      this->domainIslands_parser_ = &p;
    }

    void intersection_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& nodeID,
             ::sim_mob::xml::Point2D_t_pskel& location,
             ::xml_schema::string_pskel& originalDB_ID,
             ::sim_mob::xml::RoadSegmentsAt_t_pskel& roadSegmentsAt,
             ::sim_mob::xml::Multi_Connectors_t_pskel& Connectors,
             ::sim_mob::xml::ChunkLengths_t_pskel& ChunkLengths,
             ::sim_mob::xml::offsets_t_pskel& Offsets,
             ::sim_mob::xml::separators_t_pskel& Separators,
             ::sim_mob::xml::LanesVector_t_pskel& additionalDominantLanes,
             ::sim_mob::xml::LanesVector_t_pskel& additionalSubdominantLanes,
             ::sim_mob::xml::DomainIslands_t_pskel& domainIslands)
    {
      this->nodeID_parser_ = &nodeID;
      this->location_parser_ = &location;
      this->originalDB_ID_parser_ = &originalDB_ID;
      this->roadSegmentsAt_parser_ = &roadSegmentsAt;
      this->Connectors_parser_ = &Connectors;
      this->ChunkLengths_parser_ = &ChunkLengths;
      this->Offsets_parser_ = &Offsets;
      this->Separators_parser_ = &Separators;
      this->additionalDominantLanes_parser_ = &additionalDominantLanes;
      this->additionalSubdominantLanes_parser_ = &additionalSubdominantLanes;
      this->domainIslands_parser_ = &domainIslands;
    }

    intersection_t_pskel::
    intersection_t_pskel ()
    : roadSegmentsAt_parser_ (0),
      Connectors_parser_ (0),
      ChunkLengths_parser_ (0),
      Offsets_parser_ (0),
      Separators_parser_ (0),
      additionalDominantLanes_parser_ (0),
      additionalSubdominantLanes_parser_ (0),
      domainIslands_parser_ (0)
    {
    }

    // RoadItem_t_pskel
    //

    void RoadItem_t_pskel::
    id_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->id_parser_ = &p;
    }

    void RoadItem_t_pskel::
    Offset_parser (::xml_schema::unsigned_short_pskel& p)
    {
      this->Offset_parser_ = &p;
    }

    void RoadItem_t_pskel::
    start_parser (::sim_mob::xml::Point2D_t_pskel& p)
    {
      this->start_parser_ = &p;
    }

    void RoadItem_t_pskel::
    end_parser (::sim_mob::xml::Point2D_t_pskel& p)
    {
      this->end_parser_ = &p;
    }

    void RoadItem_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& id,
             ::xml_schema::unsigned_short_pskel& Offset,
             ::sim_mob::xml::Point2D_t_pskel& start,
             ::sim_mob::xml::Point2D_t_pskel& end)
    {
      this->id_parser_ = &id;
      this->Offset_parser_ = &Offset;
      this->start_parser_ = &start;
      this->end_parser_ = &end;
    }

    RoadItem_t_pskel::
    RoadItem_t_pskel ()
    : id_parser_ (0),
      Offset_parser_ (0),
      start_parser_ (0),
      end_parser_ (0)
    {
    }

    // BusStop_t_pskel
    //

    void BusStop_t_pskel::
    xPos_parser (::xml_schema::double_pskel& p)
    {
      this->xPos_parser_ = &p;
    }

    void BusStop_t_pskel::
    yPos_parser (::xml_schema::double_pskel& p)
    {
      this->yPos_parser_ = &p;
    }

    void BusStop_t_pskel::
    lane_location_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->lane_location_parser_ = &p;
    }

    void BusStop_t_pskel::
    is_terminal_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_terminal_parser_ = &p;
    }

    void BusStop_t_pskel::
    is_bay_parser (::xml_schema::boolean_pskel& p)
    {
      this->is_bay_parser_ = &p;
    }

    void BusStop_t_pskel::
    has_shelter_parser (::xml_schema::boolean_pskel& p)
    {
      this->has_shelter_parser_ = &p;
    }

    void BusStop_t_pskel::
    busCapacityAsLength_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->busCapacityAsLength_parser_ = &p;
    }

    void BusStop_t_pskel::
    busstopno_parser (::xml_schema::string_pskel& p)
    {
      this->busstopno_parser_ = &p;
    }

    void BusStop_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& id,
             ::xml_schema::unsigned_short_pskel& Offset,
             ::sim_mob::xml::Point2D_t_pskel& start,
             ::sim_mob::xml::Point2D_t_pskel& end,
             ::xml_schema::double_pskel& xPos,
             ::xml_schema::double_pskel& yPos,
             ::xml_schema::unsigned_long_pskel& lane_location,
             ::xml_schema::boolean_pskel& is_terminal,
             ::xml_schema::boolean_pskel& is_bay,
             ::xml_schema::boolean_pskel& has_shelter,
             ::xml_schema::unsigned_int_pskel& busCapacityAsLength,
             ::xml_schema::string_pskel& busstopno)
    {
      this->id_parser_ = &id;
      this->Offset_parser_ = &Offset;
      this->start_parser_ = &start;
      this->end_parser_ = &end;
      this->xPos_parser_ = &xPos;
      this->yPos_parser_ = &yPos;
      this->lane_location_parser_ = &lane_location;
      this->is_terminal_parser_ = &is_terminal;
      this->is_bay_parser_ = &is_bay;
      this->has_shelter_parser_ = &has_shelter;
      this->busCapacityAsLength_parser_ = &busCapacityAsLength;
      this->busstopno_parser_ = &busstopno;
    }

    BusStop_t_pskel::
    BusStop_t_pskel ()
    : xPos_parser_ (0),
      yPos_parser_ (0),
      lane_location_parser_ (0),
      is_terminal_parser_ (0),
      is_bay_parser_ (0),
      has_shelter_parser_ (0),
      busCapacityAsLength_parser_ (0),
      busstopno_parser_ (0)
    {
    }

    // ERP_Gantry_t_pskel
    //

    void ERP_Gantry_t_pskel::
    ERP_GantryID_parser (::xml_schema::string_pskel& p)
    {
      this->ERP_GantryID_parser_ = &p;
    }

    void ERP_Gantry_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& id,
             ::xml_schema::unsigned_short_pskel& Offset,
             ::sim_mob::xml::Point2D_t_pskel& start,
             ::sim_mob::xml::Point2D_t_pskel& end,
             ::xml_schema::string_pskel& ERP_GantryID)
    {
      this->id_parser_ = &id;
      this->Offset_parser_ = &Offset;
      this->start_parser_ = &start;
      this->end_parser_ = &end;
      this->ERP_GantryID_parser_ = &ERP_GantryID;
    }

    ERP_Gantry_t_pskel::
    ERP_Gantry_t_pskel ()
    : ERP_GantryID_parser_ (0)
    {
    }

    // FormType_pskel
    //

    void FormType_pskel::
    TextBox_parser (::xml_schema::int_pskel& p)
    {
      this->TextBox_parser_ = &p;
    }

    void FormType_pskel::
    TextArea_parser (::xml_schema::int_pskel& p)
    {
      this->TextArea_parser_ = &p;
    }

    void FormType_pskel::
    Header_parser (::xml_schema::int_pskel& p)
    {
      this->Header_parser_ = &p;
    }

    void FormType_pskel::
    parsers (::xml_schema::int_pskel& TextBox,
             ::xml_schema::int_pskel& TextArea,
             ::xml_schema::int_pskel& Header)
    {
      this->TextBox_parser_ = &TextBox;
      this->TextArea_parser_ = &TextArea;
      this->Header_parser_ = &Header;
    }

    FormType_pskel::
    FormType_pskel ()
    : TextBox_parser_ (0),
      TextArea_parser_ (0),
      Header_parser_ (0)
    {
    }

    // PointPair_t_pskel
    //

    void PointPair_t_pskel::
    first_parser (::sim_mob::xml::Point2D_t_pskel& p)
    {
      this->first_parser_ = &p;
    }

    void PointPair_t_pskel::
    second_parser (::sim_mob::xml::Point2D_t_pskel& p)
    {
      this->second_parser_ = &p;
    }

    void PointPair_t_pskel::
    parsers (::sim_mob::xml::Point2D_t_pskel& first,
             ::sim_mob::xml::Point2D_t_pskel& second)
    {
      this->first_parser_ = &first;
      this->second_parser_ = &second;
    }

    PointPair_t_pskel::
    PointPair_t_pskel ()
    : first_parser_ (0),
      second_parser_ (0)
    {
    }

    // crossing_t_pskel
    //

    void crossing_t_pskel::
    nearLine_parser (::sim_mob::xml::PointPair_t_pskel& p)
    {
      this->nearLine_parser_ = &p;
    }

    void crossing_t_pskel::
    farLine_parser (::sim_mob::xml::PointPair_t_pskel& p)
    {
      this->farLine_parser_ = &p;
    }

    void crossing_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& id,
             ::xml_schema::unsigned_short_pskel& Offset,
             ::sim_mob::xml::Point2D_t_pskel& start,
             ::sim_mob::xml::Point2D_t_pskel& end,
             ::sim_mob::xml::PointPair_t_pskel& nearLine,
             ::sim_mob::xml::PointPair_t_pskel& farLine)
    {
      this->id_parser_ = &id;
      this->Offset_parser_ = &Offset;
      this->start_parser_ = &start;
      this->end_parser_ = &end;
      this->nearLine_parser_ = &nearLine;
      this->farLine_parser_ = &farLine;
    }

    crossing_t_pskel::
    crossing_t_pskel ()
    : nearLine_parser_ (0),
      farLine_parser_ (0)
    {
    }

    // RoadBump_t_pskel
    //

    void RoadBump_t_pskel::
    roadBumpID_parser (::xml_schema::string_pskel& p)
    {
      this->roadBumpID_parser_ = &p;
    }

    void RoadBump_t_pskel::
    segmentID_parser (::xml_schema::unsigned_long_pskel& p)
    {
      this->segmentID_parser_ = &p;
    }

    void RoadBump_t_pskel::
    parsers (::xml_schema::unsigned_long_pskel& id,
             ::xml_schema::unsigned_short_pskel& Offset,
             ::sim_mob::xml::Point2D_t_pskel& start,
             ::sim_mob::xml::Point2D_t_pskel& end,
             ::xml_schema::string_pskel& roadBumpID,
             ::xml_schema::unsigned_long_pskel& segmentID)
    {
      this->id_parser_ = &id;
      this->Offset_parser_ = &Offset;
      this->start_parser_ = &start;
      this->end_parser_ = &end;
      this->roadBumpID_parser_ = &roadBumpID;
      this->segmentID_parser_ = &segmentID;
    }

    RoadBump_t_pskel::
    RoadBump_t_pskel ()
    : roadBumpID_parser_ (0),
      segmentID_parser_ (0)
    {
    }

    // RoadNetwork_t_pskel
    //

    void RoadNetwork_t_pskel::
    Nodes_parser (::sim_mob::xml::Nodes_pskel& p)
    {
      this->Nodes_parser_ = &p;
    }

    void RoadNetwork_t_pskel::
    Links_parser (::sim_mob::xml::Links_pskel& p)
    {
      this->Links_parser_ = &p;
    }

    void RoadNetwork_t_pskel::
    parsers (::sim_mob::xml::Nodes_pskel& Nodes,
             ::sim_mob::xml::Links_pskel& Links)
    {
      this->Nodes_parser_ = &Nodes;
      this->Links_parser_ = &Links;
    }

    RoadNetwork_t_pskel::
    RoadNetwork_t_pskel ()
    : Nodes_parser_ (0),
      Links_parser_ (0)
    {
    }

    // RoadItems_t_pskel
    //

    void RoadItems_t_pskel::
    BusStop_parser (::sim_mob::xml::BusStop_t_pskel& p)
    {
      this->BusStop_parser_ = &p;
    }

    void RoadItems_t_pskel::
    ERP_Gantry_parser (::sim_mob::xml::ERP_Gantry_t_pskel& p)
    {
      this->ERP_Gantry_parser_ = &p;
    }

    void RoadItems_t_pskel::
    Crossing_parser (::sim_mob::xml::crossing_t_pskel& p)
    {
      this->Crossing_parser_ = &p;
    }

    void RoadItems_t_pskel::
    RoadBump_parser (::sim_mob::xml::RoadBump_t_pskel& p)
    {
      this->RoadBump_parser_ = &p;
    }

    void RoadItems_t_pskel::
    parsers (::sim_mob::xml::BusStop_t_pskel& BusStop,
             ::sim_mob::xml::ERP_Gantry_t_pskel& ERP_Gantry,
             ::sim_mob::xml::crossing_t_pskel& Crossing,
             ::sim_mob::xml::RoadBump_t_pskel& RoadBump)
    {
      this->BusStop_parser_ = &BusStop;
      this->ERP_Gantry_parser_ = &ERP_Gantry;
      this->Crossing_parser_ = &Crossing;
      this->RoadBump_parser_ = &RoadBump;
    }

    RoadItems_t_pskel::
    RoadItems_t_pskel ()
    : BusStop_parser_ (0),
      ERP_Gantry_parser_ (0),
      Crossing_parser_ (0),
      RoadBump_parser_ (0)
    {
    }

    // TripChainItem_t_pskel
    //

    void TripChainItem_t_pskel::
    personID_parser (::xml_schema::string_pskel& p)
    {
      this->personID_parser_ = &p;
    }

    void TripChainItem_t_pskel::
    itemType_parser (::sim_mob::xml::TripchainItemType_pskel& p)
    {
      this->itemType_parser_ = &p;
    }

    void TripChainItem_t_pskel::
    sequenceNumber_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->sequenceNumber_parser_ = &p;
    }

    void TripChainItem_t_pskel::
    requestTime_parser (::xml_schema::integer_pskel& p)
    {
      this->requestTime_parser_ = &p;
    }

    void TripChainItem_t_pskel::
    startTime_parser (::xml_schema::string_pskel& p)
    {
      this->startTime_parser_ = &p;
    }

    void TripChainItem_t_pskel::
    endTime_parser (::xml_schema::string_pskel& p)
    {
      this->endTime_parser_ = &p;
    }

    void TripChainItem_t_pskel::
    parsers (::xml_schema::string_pskel& personID,
             ::sim_mob::xml::TripchainItemType_pskel& itemType,
             ::xml_schema::unsigned_int_pskel& sequenceNumber,
             ::xml_schema::integer_pskel& requestTime,
             ::xml_schema::string_pskel& startTime,
             ::xml_schema::string_pskel& endTime)
    {
      this->personID_parser_ = &personID;
      this->itemType_parser_ = &itemType;
      this->sequenceNumber_parser_ = &sequenceNumber;
      this->requestTime_parser_ = &requestTime;
      this->startTime_parser_ = &startTime;
      this->endTime_parser_ = &endTime;
    }

    TripChainItem_t_pskel::
    TripChainItem_t_pskel ()
    : personID_parser_ (0),
      itemType_parser_ (0),
      sequenceNumber_parser_ (0),
      requestTime_parser_ (0),
      startTime_parser_ (0),
      endTime_parser_ (0)
    {
    }

    // Trip_t_pskel
    //

    void Trip_t_pskel::
    tripID_parser (::xml_schema::integer_pskel& p)
    {
      this->tripID_parser_ = &p;
    }

    void Trip_t_pskel::
    fromLocation_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->fromLocation_parser_ = &p;
    }

    void Trip_t_pskel::
    fromLocationType_parser (::sim_mob::xml::TripchainItemLocationType_pskel& p)
    {
      this->fromLocationType_parser_ = &p;
    }

    void Trip_t_pskel::
    toLocation_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->toLocation_parser_ = &p;
    }

    void Trip_t_pskel::
    toLocationType_parser (::sim_mob::xml::TripchainItemLocationType_pskel& p)
    {
      this->toLocationType_parser_ = &p;
    }

    void Trip_t_pskel::
    subTrips_parser (::sim_mob::xml::SubTrips_t_pskel& p)
    {
      this->subTrips_parser_ = &p;
    }

    void Trip_t_pskel::
    parsers (::xml_schema::string_pskel& personID,
             ::sim_mob::xml::TripchainItemType_pskel& itemType,
             ::xml_schema::unsigned_int_pskel& sequenceNumber,
             ::xml_schema::integer_pskel& requestTime,
             ::xml_schema::string_pskel& startTime,
             ::xml_schema::string_pskel& endTime,
             ::xml_schema::integer_pskel& tripID,
             ::xml_schema::unsigned_int_pskel& fromLocation,
             ::sim_mob::xml::TripchainItemLocationType_pskel& fromLocationType,
             ::xml_schema::unsigned_int_pskel& toLocation,
             ::sim_mob::xml::TripchainItemLocationType_pskel& toLocationType,
             ::sim_mob::xml::SubTrips_t_pskel& subTrips)
    {
      this->personID_parser_ = &personID;
      this->itemType_parser_ = &itemType;
      this->sequenceNumber_parser_ = &sequenceNumber;
      this->requestTime_parser_ = &requestTime;
      this->startTime_parser_ = &startTime;
      this->endTime_parser_ = &endTime;
      this->tripID_parser_ = &tripID;
      this->fromLocation_parser_ = &fromLocation;
      this->fromLocationType_parser_ = &fromLocationType;
      this->toLocation_parser_ = &toLocation;
      this->toLocationType_parser_ = &toLocationType;
      this->subTrips_parser_ = &subTrips;
    }

    Trip_t_pskel::
    Trip_t_pskel ()
    : tripID_parser_ (0),
      fromLocation_parser_ (0),
      fromLocationType_parser_ (0),
      toLocation_parser_ (0),
      toLocationType_parser_ (0),
      subTrips_parser_ (0)
    {
    }

    // SubTrip_t_pskel
    //

    void SubTrip_t_pskel::
    mode_parser (::xml_schema::string_pskel& p)
    {
      this->mode_parser_ = &p;
    }

    void SubTrip_t_pskel::
    isPrimaryMode_parser (::xml_schema::boolean_pskel& p)
    {
      this->isPrimaryMode_parser_ = &p;
    }

    void SubTrip_t_pskel::
    ptLineId_parser (::xml_schema::string_pskel& p)
    {
      this->ptLineId_parser_ = &p;
    }

    void SubTrip_t_pskel::
    parsers (::xml_schema::string_pskel& personID,
             ::sim_mob::xml::TripchainItemType_pskel& itemType,
             ::xml_schema::unsigned_int_pskel& sequenceNumber,
             ::xml_schema::integer_pskel& requestTime,
             ::xml_schema::string_pskel& startTime,
             ::xml_schema::string_pskel& endTime,
             ::xml_schema::integer_pskel& tripID,
             ::xml_schema::unsigned_int_pskel& fromLocation,
             ::sim_mob::xml::TripchainItemLocationType_pskel& fromLocationType,
             ::xml_schema::unsigned_int_pskel& toLocation,
             ::sim_mob::xml::TripchainItemLocationType_pskel& toLocationType,
             ::sim_mob::xml::SubTrips_t_pskel& subTrips,
             ::xml_schema::string_pskel& mode,
             ::xml_schema::boolean_pskel& isPrimaryMode,
             ::xml_schema::string_pskel& ptLineId)
    {
      this->personID_parser_ = &personID;
      this->itemType_parser_ = &itemType;
      this->sequenceNumber_parser_ = &sequenceNumber;
      this->requestTime_parser_ = &requestTime;
      this->startTime_parser_ = &startTime;
      this->endTime_parser_ = &endTime;
      this->tripID_parser_ = &tripID;
      this->fromLocation_parser_ = &fromLocation;
      this->fromLocationType_parser_ = &fromLocationType;
      this->toLocation_parser_ = &toLocation;
      this->toLocationType_parser_ = &toLocationType;
      this->subTrips_parser_ = &subTrips;
      this->mode_parser_ = &mode;
      this->isPrimaryMode_parser_ = &isPrimaryMode;
      this->ptLineId_parser_ = &ptLineId;
    }

    SubTrip_t_pskel::
    SubTrip_t_pskel ()
    : mode_parser_ (0),
      isPrimaryMode_parser_ (0),
      ptLineId_parser_ (0)
    {
    }

    // SubTrips_t_pskel
    //

    void SubTrips_t_pskel::
    subTrip_parser (::sim_mob::xml::SubTrip_t_pskel& p)
    {
      this->subTrip_parser_ = &p;
    }

    void SubTrips_t_pskel::
    parsers (::sim_mob::xml::SubTrip_t_pskel& subTrip)
    {
      this->subTrip_parser_ = &subTrip;
    }

    SubTrips_t_pskel::
    SubTrips_t_pskel ()
    : subTrip_parser_ (0)
    {
    }

    // Activity_t_pskel
    //

    void Activity_t_pskel::
    description_parser (::xml_schema::string_pskel& p)
    {
      this->description_parser_ = &p;
    }

    void Activity_t_pskel::
    location_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->location_parser_ = &p;
    }

    void Activity_t_pskel::
    locationType_parser (::sim_mob::xml::TripchainItemLocationType_pskel& p)
    {
      this->locationType_parser_ = &p;
    }

    void Activity_t_pskel::
    isPrimary_parser (::xml_schema::boolean_pskel& p)
    {
      this->isPrimary_parser_ = &p;
    }

    void Activity_t_pskel::
    isFlexible_parser (::xml_schema::boolean_pskel& p)
    {
      this->isFlexible_parser_ = &p;
    }

    void Activity_t_pskel::
    isMandatory_parser (::xml_schema::boolean_pskel& p)
    {
      this->isMandatory_parser_ = &p;
    }

    void Activity_t_pskel::
    parsers (::xml_schema::string_pskel& personID,
             ::sim_mob::xml::TripchainItemType_pskel& itemType,
             ::xml_schema::unsigned_int_pskel& sequenceNumber,
             ::xml_schema::integer_pskel& requestTime,
             ::xml_schema::string_pskel& startTime,
             ::xml_schema::string_pskel& endTime,
             ::xml_schema::string_pskel& description,
             ::xml_schema::unsigned_int_pskel& location,
             ::sim_mob::xml::TripchainItemLocationType_pskel& locationType,
             ::xml_schema::boolean_pskel& isPrimary,
             ::xml_schema::boolean_pskel& isFlexible,
             ::xml_schema::boolean_pskel& isMandatory)
    {
      this->personID_parser_ = &personID;
      this->itemType_parser_ = &itemType;
      this->sequenceNumber_parser_ = &sequenceNumber;
      this->requestTime_parser_ = &requestTime;
      this->startTime_parser_ = &startTime;
      this->endTime_parser_ = &endTime;
      this->description_parser_ = &description;
      this->location_parser_ = &location;
      this->locationType_parser_ = &locationType;
      this->isPrimary_parser_ = &isPrimary;
      this->isFlexible_parser_ = &isFlexible;
      this->isMandatory_parser_ = &isMandatory;
    }

    Activity_t_pskel::
    Activity_t_pskel ()
    : description_parser_ (0),
      location_parser_ (0),
      locationType_parser_ (0),
      isPrimary_parser_ (0),
      isFlexible_parser_ (0),
      isMandatory_parser_ (0)
    {
    }

    // TripChain_t_pskel
    //

    void TripChain_t_pskel::
    personID_parser (::xml_schema::string_pskel& p)
    {
      this->personID_parser_ = &p;
    }

    void TripChain_t_pskel::
    Trip_parser (::sim_mob::xml::Trip_t_pskel& p)
    {
      this->Trip_parser_ = &p;
    }

    void TripChain_t_pskel::
    Activity_parser (::sim_mob::xml::Activity_t_pskel& p)
    {
      this->Activity_parser_ = &p;
    }

    void TripChain_t_pskel::
    parsers (::xml_schema::string_pskel& personID,
             ::sim_mob::xml::Trip_t_pskel& Trip,
             ::sim_mob::xml::Activity_t_pskel& Activity)
    {
      this->personID_parser_ = &personID;
      this->Trip_parser_ = &Trip;
      this->Activity_parser_ = &Activity;
    }

    TripChain_t_pskel::
    TripChain_t_pskel ()
    : personID_parser_ (0),
      Trip_parser_ (0),
      Activity_parser_ (0)
    {
    }

    // TripChains_t_pskel
    //

    void TripChains_t_pskel::
    TripChain_parser (::sim_mob::xml::TripChain_t_pskel& p)
    {
      this->TripChain_parser_ = &p;
    }

    void TripChains_t_pskel::
    parsers (::sim_mob::xml::TripChain_t_pskel& TripChain)
    {
      this->TripChain_parser_ = &TripChain;
    }

    TripChains_t_pskel::
    TripChains_t_pskel ()
    : TripChain_parser_ (0)
    {
    }

    // linkAndCrossing_t_pskel
    //

    void linkAndCrossing_t_pskel::
    ID_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->ID_parser_ = &p;
    }

    void linkAndCrossing_t_pskel::
    linkID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->linkID_parser_ = &p;
    }

    void linkAndCrossing_t_pskel::
    crossingID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->crossingID_parser_ = &p;
    }

    void linkAndCrossing_t_pskel::
    angle_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->angle_parser_ = &p;
    }

    void linkAndCrossing_t_pskel::
    parsers (::xml_schema::unsigned_byte_pskel& ID,
             ::xml_schema::unsigned_int_pskel& linkID,
             ::xml_schema::unsigned_int_pskel& crossingID,
             ::xml_schema::unsigned_byte_pskel& angle)
    {
      this->ID_parser_ = &ID;
      this->linkID_parser_ = &linkID;
      this->crossingID_parser_ = &crossingID;
      this->angle_parser_ = &angle;
    }

    linkAndCrossing_t_pskel::
    linkAndCrossing_t_pskel ()
    : ID_parser_ (0),
      linkID_parser_ (0),
      crossingID_parser_ (0),
      angle_parser_ (0)
    {
    }

    // linkAndCrossings_t_pskel
    //

    void linkAndCrossings_t_pskel::
    linkAndCrossing_parser (::sim_mob::xml::linkAndCrossing_t_pskel& p)
    {
      this->linkAndCrossing_parser_ = &p;
    }

    void linkAndCrossings_t_pskel::
    parsers (::sim_mob::xml::linkAndCrossing_t_pskel& linkAndCrossing)
    {
      this->linkAndCrossing_parser_ = &linkAndCrossing;
    }

    linkAndCrossings_t_pskel::
    linkAndCrossings_t_pskel ()
    : linkAndCrossing_parser_ (0)
    {
    }

    // Plan_t_pskel
    //

    void Plan_t_pskel::
    planID_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->planID_parser_ = &p;
    }

    void Plan_t_pskel::
    PhasePercentage_parser (::xml_schema::double_pskel& p)
    {
      this->PhasePercentage_parser_ = &p;
    }

    void Plan_t_pskel::
    parsers (::xml_schema::unsigned_byte_pskel& planID,
             ::xml_schema::double_pskel& PhasePercentage)
    {
      this->planID_parser_ = &planID;
      this->PhasePercentage_parser_ = &PhasePercentage;
    }

    Plan_t_pskel::
    Plan_t_pskel ()
    : planID_parser_ (0),
      PhasePercentage_parser_ (0)
    {
    }

    // Plans_t_pskel
    //

    void Plans_t_pskel::
    plan_parser (::sim_mob::xml::Plan_t_pskel& p)
    {
      this->plan_parser_ = &p;
    }

    void Plans_t_pskel::
    parsers (::sim_mob::xml::Plan_t_pskel& plan)
    {
      this->plan_parser_ = &plan;
    }

    Plans_t_pskel::
    Plans_t_pskel ()
    : plan_parser_ (0)
    {
    }

    // ColorDuration_t_pskel
    //

    void ColorDuration_t_pskel::
    TrafficColor_parser (::sim_mob::xml::TrafficColor_t_pskel& p)
    {
      this->TrafficColor_parser_ = &p;
    }

    void ColorDuration_t_pskel::
    Duration_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->Duration_parser_ = &p;
    }

    void ColorDuration_t_pskel::
    parsers (::sim_mob::xml::TrafficColor_t_pskel& TrafficColor,
             ::xml_schema::unsigned_byte_pskel& Duration)
    {
      this->TrafficColor_parser_ = &TrafficColor;
      this->Duration_parser_ = &Duration;
    }

    ColorDuration_t_pskel::
    ColorDuration_t_pskel ()
    : TrafficColor_parser_ (0),
      Duration_parser_ (0)
    {
    }

    // ColorSequence_t_pskel
    //

    void ColorSequence_t_pskel::
    TrafficLightType_parser (::xml_schema::string_pskel& p)
    {
      this->TrafficLightType_parser_ = &p;
    }

    void ColorSequence_t_pskel::
    ColorDuration_parser (::sim_mob::xml::ColorDuration_t_pskel& p)
    {
      this->ColorDuration_parser_ = &p;
    }

    void ColorSequence_t_pskel::
    parsers (::xml_schema::string_pskel& TrafficLightType,
             ::sim_mob::xml::ColorDuration_t_pskel& ColorDuration)
    {
      this->TrafficLightType_parser_ = &TrafficLightType;
      this->ColorDuration_parser_ = &ColorDuration;
    }

    ColorSequence_t_pskel::
    ColorSequence_t_pskel ()
    : TrafficLightType_parser_ (0),
      ColorDuration_parser_ (0)
    {
    }

    // links_maps_t_pskel
    //

    void links_maps_t_pskel::
    links_map_parser (::sim_mob::xml::links_map_t_pskel& p)
    {
      this->links_map_parser_ = &p;
    }

    void links_maps_t_pskel::
    parsers (::sim_mob::xml::links_map_t_pskel& links_map)
    {
      this->links_map_parser_ = &links_map;
    }

    links_maps_t_pskel::
    links_maps_t_pskel ()
    : links_map_parser_ (0)
    {
    }

    // links_map_t_pskel
    //

    void links_map_t_pskel::
    linkFrom_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->linkFrom_parser_ = &p;
    }

    void links_map_t_pskel::
    linkTo_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->linkTo_parser_ = &p;
    }

    void links_map_t_pskel::
    SegmentFrom_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->SegmentFrom_parser_ = &p;
    }

    void links_map_t_pskel::
    SegmentTo_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->SegmentTo_parser_ = &p;
    }

    void links_map_t_pskel::
    ColorSequence_parser (::sim_mob::xml::ColorSequence_t_pskel& p)
    {
      this->ColorSequence_parser_ = &p;
    }

    void links_map_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& linkFrom,
             ::xml_schema::unsigned_int_pskel& linkTo,
             ::xml_schema::unsigned_int_pskel& SegmentFrom,
             ::xml_schema::unsigned_int_pskel& SegmentTo,
             ::sim_mob::xml::ColorSequence_t_pskel& ColorSequence)
    {
      this->linkFrom_parser_ = &linkFrom;
      this->linkTo_parser_ = &linkTo;
      this->SegmentFrom_parser_ = &SegmentFrom;
      this->SegmentTo_parser_ = &SegmentTo;
      this->ColorSequence_parser_ = &ColorSequence;
    }

    links_map_t_pskel::
    links_map_t_pskel ()
    : linkFrom_parser_ (0),
      linkTo_parser_ (0),
      SegmentFrom_parser_ (0),
      SegmentTo_parser_ (0),
      ColorSequence_parser_ (0)
    {
    }

    // crossings_maps_t_pskel
    //

    void crossings_maps_t_pskel::
    crossings_map_parser (::sim_mob::xml::crossings_map_t_pskel& p)
    {
      this->crossings_map_parser_ = &p;
    }

    void crossings_maps_t_pskel::
    parsers (::sim_mob::xml::crossings_map_t_pskel& crossings_map)
    {
      this->crossings_map_parser_ = &crossings_map;
    }

    crossings_maps_t_pskel::
    crossings_maps_t_pskel ()
    : crossings_map_parser_ (0)
    {
    }

    // crossings_map_t_pskel
    //

    void crossings_map_t_pskel::
    linkID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->linkID_parser_ = &p;
    }

    void crossings_map_t_pskel::
    crossingID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->crossingID_parser_ = &p;
    }

    void crossings_map_t_pskel::
    ColorSequence_parser (::sim_mob::xml::ColorSequence_t_pskel& p)
    {
      this->ColorSequence_parser_ = &p;
    }

    void crossings_map_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& linkID,
             ::xml_schema::unsigned_int_pskel& crossingID,
             ::sim_mob::xml::ColorSequence_t_pskel& ColorSequence)
    {
      this->linkID_parser_ = &linkID;
      this->crossingID_parser_ = &crossingID;
      this->ColorSequence_parser_ = &ColorSequence;
    }

    crossings_map_t_pskel::
    crossings_map_t_pskel ()
    : linkID_parser_ (0),
      crossingID_parser_ (0),
      ColorSequence_parser_ (0)
    {
    }

    // Phase_t_pskel
    //

    void Phase_t_pskel::
    phaseID_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->phaseID_parser_ = &p;
    }

    void Phase_t_pskel::
    name_parser (::xml_schema::string_pskel& p)
    {
      this->name_parser_ = &p;
    }

    void Phase_t_pskel::
    links_maps_parser (::sim_mob::xml::links_maps_t_pskel& p)
    {
      this->links_maps_parser_ = &p;
    }

    void Phase_t_pskel::
    crossings_maps_parser (::sim_mob::xml::crossings_maps_t_pskel& p)
    {
      this->crossings_maps_parser_ = &p;
    }

    void Phase_t_pskel::
    parsers (::xml_schema::unsigned_byte_pskel& phaseID,
             ::xml_schema::string_pskel& name,
             ::sim_mob::xml::links_maps_t_pskel& links_maps,
             ::sim_mob::xml::crossings_maps_t_pskel& crossings_maps)
    {
      this->phaseID_parser_ = &phaseID;
      this->name_parser_ = &name;
      this->links_maps_parser_ = &links_maps;
      this->crossings_maps_parser_ = &crossings_maps;
    }

    Phase_t_pskel::
    Phase_t_pskel ()
    : phaseID_parser_ (0),
      name_parser_ (0),
      links_maps_parser_ (0),
      crossings_maps_parser_ (0)
    {
    }

    // Phases_t_pskel
    //

    void Phases_t_pskel::
    phase_parser (::sim_mob::xml::Phase_t_pskel& p)
    {
      this->phase_parser_ = &p;
    }

    void Phases_t_pskel::
    parsers (::sim_mob::xml::Phase_t_pskel& phase)
    {
      this->phase_parser_ = &phase;
    }

    Phases_t_pskel::
    Phases_t_pskel ()
    : phase_parser_ (0)
    {
    }

    // SplitPlan_t_pskel
    //

    void SplitPlan_t_pskel::
    splitplanID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->splitplanID_parser_ = &p;
    }

    void SplitPlan_t_pskel::
    cycleLength_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->cycleLength_parser_ = &p;
    }

    void SplitPlan_t_pskel::
    offset_parser (::xml_schema::unsigned_byte_pskel& p)
    {
      this->offset_parser_ = &p;
    }

    void SplitPlan_t_pskel::
    ChoiceSet_parser (::sim_mob::xml::Plans_t_pskel& p)
    {
      this->ChoiceSet_parser_ = &p;
    }

    void SplitPlan_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& splitplanID,
             ::xml_schema::unsigned_byte_pskel& cycleLength,
             ::xml_schema::unsigned_byte_pskel& offset,
             ::sim_mob::xml::Plans_t_pskel& ChoiceSet)
    {
      this->splitplanID_parser_ = &splitplanID;
      this->cycleLength_parser_ = &cycleLength;
      this->offset_parser_ = &offset;
      this->ChoiceSet_parser_ = &ChoiceSet;
    }

    SplitPlan_t_pskel::
    SplitPlan_t_pskel ()
    : splitplanID_parser_ (0),
      cycleLength_parser_ (0),
      offset_parser_ (0),
      ChoiceSet_parser_ (0)
    {
    }

    // SCATS_t_pskel
    //

    void SCATS_t_pskel::
    signalTimingMode_parser (::sim_mob::xml::signalTimingMode_t_pskel& p)
    {
      this->signalTimingMode_parser_ = &p;
    }

    void SCATS_t_pskel::
    SplitPlan_parser (::sim_mob::xml::SplitPlan_t_pskel& p)
    {
      this->SplitPlan_parser_ = &p;
    }

    void SCATS_t_pskel::
    parsers (::sim_mob::xml::signalTimingMode_t_pskel& signalTimingMode,
             ::sim_mob::xml::SplitPlan_t_pskel& SplitPlan)
    {
      this->signalTimingMode_parser_ = &signalTimingMode;
      this->SplitPlan_parser_ = &SplitPlan;
    }

    SCATS_t_pskel::
    SCATS_t_pskel ()
    : signalTimingMode_parser_ (0),
      SplitPlan_parser_ (0)
    {
    }

    // Signal_t_pskel
    //

    void Signal_t_pskel::
    signalID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->signalID_parser_ = &p;
    }

    void Signal_t_pskel::
    nodeID_parser (::xml_schema::unsigned_int_pskel& p)
    {
      this->nodeID_parser_ = &p;
    }

    void Signal_t_pskel::
    linkAndCrossings_parser (::sim_mob::xml::linkAndCrossings_t_pskel& p)
    {
      this->linkAndCrossings_parser_ = &p;
    }

    void Signal_t_pskel::
    phases_parser (::sim_mob::xml::Phases_t_pskel& p)
    {
      this->phases_parser_ = &p;
    }

    void Signal_t_pskel::
    SCATS_parser (::sim_mob::xml::SCATS_t_pskel& p)
    {
      this->SCATS_parser_ = &p;
    }

    void Signal_t_pskel::
    parsers (::xml_schema::unsigned_int_pskel& signalID,
             ::xml_schema::unsigned_int_pskel& nodeID,
             ::sim_mob::xml::linkAndCrossings_t_pskel& linkAndCrossings,
             ::sim_mob::xml::Phases_t_pskel& phases,
             ::sim_mob::xml::SCATS_t_pskel& SCATS)
    {
      this->signalID_parser_ = &signalID;
      this->nodeID_parser_ = &nodeID;
      this->linkAndCrossings_parser_ = &linkAndCrossings;
      this->phases_parser_ = &phases;
      this->SCATS_parser_ = &SCATS;
    }

    Signal_t_pskel::
    Signal_t_pskel ()
    : signalID_parser_ (0),
      nodeID_parser_ (0),
      linkAndCrossings_parser_ (0),
      phases_parser_ (0),
      SCATS_parser_ (0)
    {
    }

    // Signals_t_pskel
    //

    void Signals_t_pskel::
    Signal_parser (::sim_mob::xml::Signal_t_pskel& p)
    {
      this->Signal_parser_ = &p;
    }

    void Signals_t_pskel::
    parsers (::sim_mob::xml::Signal_t_pskel& Signal)
    {
      this->Signal_parser_ = &Signal;
    }

    Signals_t_pskel::
    Signals_t_pskel ()
    : Signal_parser_ (0)
    {
    }

    // GeoSpatial_t_pskel
    //

    void GeoSpatial_t_pskel::
    RoadNetwork_parser (::sim_mob::xml::RoadNetwork_t_pskel& p)
    {
      this->RoadNetwork_parser_ = &p;
    }

    void GeoSpatial_t_pskel::
    parsers (::sim_mob::xml::RoadNetwork_t_pskel& RoadNetwork)
    {
      this->RoadNetwork_parser_ = &RoadNetwork;
    }

    GeoSpatial_t_pskel::
    GeoSpatial_t_pskel ()
    : RoadNetwork_parser_ (0)
    {
    }

    // SimMobility_t_pskel
    //

    void SimMobility_t_pskel::
    GeoSpatial_parser (::sim_mob::xml::GeoSpatial_t_pskel& p)
    {
      this->GeoSpatial_parser_ = &p;
    }

    void SimMobility_t_pskel::
    TripChains_parser (::sim_mob::xml::TripChains_t_pskel& p)
    {
      this->TripChains_parser_ = &p;
    }

    void SimMobility_t_pskel::
    Signals_parser (::sim_mob::xml::Signals_t_pskel& p)
    {
      this->Signals_parser_ = &p;
    }

    void SimMobility_t_pskel::
    parsers (::sim_mob::xml::GeoSpatial_t_pskel& GeoSpatial,
             ::sim_mob::xml::TripChains_t_pskel& TripChains,
             ::sim_mob::xml::Signals_t_pskel& Signals)
    {
      this->GeoSpatial_parser_ = &GeoSpatial;
      this->TripChains_parser_ = &TripChains;
      this->Signals_parser_ = &Signals;
    }

    SimMobility_t_pskel::
    SimMobility_t_pskel ()
    : GeoSpatial_parser_ (0),
      TripChains_parser_ (0),
      Signals_parser_ (0)
    {
    }

    // Lanes_pskel
    //

    void Lanes_pskel::
    Lane_parser (::sim_mob::xml::lane_t_pskel& p)
    {
      this->Lane_parser_ = &p;
    }

    void Lanes_pskel::
    parsers (::sim_mob::xml::lane_t_pskel& Lane)
    {
      this->Lane_parser_ = &Lane;
    }

    Lanes_pskel::
    Lanes_pskel ()
    : Lane_parser_ (0)
    {
    }

    // Nodes_pskel
    //

    void Nodes_pskel::
    UniNodes_parser (::sim_mob::xml::UniNodes_pskel& p)
    {
      this->UniNodes_parser_ = &p;
    }

    void Nodes_pskel::
    Intersections_parser (::sim_mob::xml::Intersections_pskel& p)
    {
      this->Intersections_parser_ = &p;
    }

    void Nodes_pskel::
    roundabouts_parser (::sim_mob::xml::roundabouts_pskel& p)
    {
      this->roundabouts_parser_ = &p;
    }

    void Nodes_pskel::
    parsers (::sim_mob::xml::UniNodes_pskel& UniNodes,
             ::sim_mob::xml::Intersections_pskel& Intersections,
             ::sim_mob::xml::roundabouts_pskel& roundabouts)
    {
      this->UniNodes_parser_ = &UniNodes;
      this->Intersections_parser_ = &Intersections;
      this->roundabouts_parser_ = &roundabouts;
    }

    Nodes_pskel::
    Nodes_pskel ()
    : UniNodes_parser_ (0),
      Intersections_parser_ (0),
      roundabouts_parser_ (0)
    {
    }

    // Links_pskel
    //

    void Links_pskel::
    Link_parser (::sim_mob::xml::link_t_pskel& p)
    {
      this->Link_parser_ = &p;
    }

    void Links_pskel::
    parsers (::sim_mob::xml::link_t_pskel& Link)
    {
      this->Link_parser_ = &Link;
    }

    Links_pskel::
    Links_pskel ()
    : Link_parser_ (0)
    {
    }

    // UniNodes_pskel
    //

    void UniNodes_pskel::
    UniNode_parser (::sim_mob::xml::UniNode_t_pskel& p)
    {
      this->UniNode_parser_ = &p;
    }

    void UniNodes_pskel::
    parsers (::sim_mob::xml::UniNode_t_pskel& UniNode)
    {
      this->UniNode_parser_ = &UniNode;
    }

    UniNodes_pskel::
    UniNodes_pskel ()
    : UniNode_parser_ (0)
    {
    }

    // Intersections_pskel
    //

    void Intersections_pskel::
    Intersection_parser (::sim_mob::xml::intersection_t_pskel& p)
    {
      this->Intersection_parser_ = &p;
    }

    void Intersections_pskel::
    parsers (::sim_mob::xml::intersection_t_pskel& Intersection)
    {
      this->Intersection_parser_ = &Intersection;
    }

    Intersections_pskel::
    Intersections_pskel ()
    : Intersection_parser_ (0)
    {
    }

    // roundabouts_pskel
    //

    void roundabouts_pskel::
    roundabout_parser (::sim_mob::xml::roundabout_t_pskel& p)
    {
      this->roundabout_parser_ = &p;
    }

    void roundabouts_pskel::
    parsers (::sim_mob::xml::roundabout_t_pskel& roundabout)
    {
      this->roundabout_parser_ = &roundabout;
    }

    roundabouts_pskel::
    roundabouts_pskel ()
    : roundabout_parser_ (0)
    {
    }
  }
}

namespace sim_mob
{
  namespace xml
  {
    // Point2D_t_pskel
    //

    void Point2D_t_pskel::
    xPos (unsigned int)
    {
    }

    void Point2D_t_pskel::
    yPos (unsigned int)
    {
    }

    bool Point2D_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "xPos" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->xPos_parser_;

        if (this->xPos_parser_)
          this->xPos_parser_->pre ();

        return true;
      }

      if (n == "yPos" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->yPos_parser_;

        if (this->yPos_parser_)
          this->yPos_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Point2D_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "xPos" && ns.empty ())
      {
        if (this->xPos_parser_)
          this->xPos (this->xPos_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "yPos" && ns.empty ())
      {
        if (this->yPos_parser_)
          this->yPos (this->yPos_parser_->post_unsigned_int ());

        return true;
      }

      return false;
    }

    // PolyPoint_t_pskel
    //

    void PolyPoint_t_pskel::
    pointID (const ::std::string&)
    {
    }

    void PolyPoint_t_pskel::
    location (sim_mob::Point2D)
    {
    }

    bool PolyPoint_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "pointID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->pointID_parser_;

        if (this->pointID_parser_)
          this->pointID_parser_->pre ();

        return true;
      }

      if (n == "location" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

        if (this->location_parser_)
          this->location_parser_->pre ();

        return true;
      }

      return false;
    }

    bool PolyPoint_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "pointID" && ns.empty ())
      {
        if (this->pointID_parser_)
          this->pointID (this->pointID_parser_->post_string ());

        return true;
      }

      if (n == "location" && ns.empty ())
      {
        if (this->location_parser_)
          this->location (this->location_parser_->post_Point2D_t ());

        return true;
      }

      return false;
    }

    // PolyLine_t_pskel
    //

    void PolyLine_t_pskel::
    PolyPoint (sim_mob::Point2D)
    {
    }

    bool PolyLine_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "PolyPoint" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyPoint_parser_;

        if (this->PolyPoint_parser_)
          this->PolyPoint_parser_->pre ();

        return true;
      }

      return false;
    }

    bool PolyLine_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "PolyPoint" && ns.empty ())
      {
        if (this->PolyPoint_parser_)
          this->PolyPoint (this->PolyPoint_parser_->post_PolyPoint_t ());

        return true;
      }

      return false;
    }

    // lane_t_pskel
    //

    void lane_t_pskel::
    laneID (unsigned long long)
    {
    }

    void lane_t_pskel::
    width (unsigned int)
    {
    }

    void lane_t_pskel::
    can_go_straight (bool)
    {
    }

    void lane_t_pskel::
    can_turn_left (bool)
    {
    }

    void lane_t_pskel::
    can_turn_right (bool)
    {
    }

    void lane_t_pskel::
    can_turn_on_red_signal (bool)
    {
    }

    void lane_t_pskel::
    can_change_lane_left (bool)
    {
    }

    void lane_t_pskel::
    can_change_lane_right (bool)
    {
    }

    void lane_t_pskel::
    is_road_shoulder (bool)
    {
    }

    void lane_t_pskel::
    is_bicycle_lane (bool)
    {
    }

    void lane_t_pskel::
    is_pedestrian_lane (bool)
    {
    }

    void lane_t_pskel::
    is_vehicle_lane (bool)
    {
    }

    void lane_t_pskel::
    is_standard_bus_lane (bool)
    {
    }

    void lane_t_pskel::
    is_whole_day_bus_lane (bool)
    {
    }

    void lane_t_pskel::
    is_high_occupancy_vehicle_lane (bool)
    {
    }

    void lane_t_pskel::
    can_freely_park_here (bool)
    {
    }

    void lane_t_pskel::
    can_stop_here (bool)
    {
    }

    void lane_t_pskel::
    is_u_turn_allowed (bool)
    {
    }

    void lane_t_pskel::
    PolyLine (std::vector<sim_mob::Point2D>)
    {
    }

    bool lane_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "laneID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

        if (this->laneID_parser_)
          this->laneID_parser_->pre ();

        return true;
      }

      if (n == "width" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->width_parser_;

        if (this->width_parser_)
          this->width_parser_->pre ();

        return true;
      }

      if (n == "can_go_straight" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_go_straight_parser_;

        if (this->can_go_straight_parser_)
          this->can_go_straight_parser_->pre ();

        return true;
      }

      if (n == "can_turn_left" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_left_parser_;

        if (this->can_turn_left_parser_)
          this->can_turn_left_parser_->pre ();

        return true;
      }

      if (n == "can_turn_right" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_right_parser_;

        if (this->can_turn_right_parser_)
          this->can_turn_right_parser_->pre ();

        return true;
      }

      if (n == "can_turn_on_red_signal" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_on_red_signal_parser_;

        if (this->can_turn_on_red_signal_parser_)
          this->can_turn_on_red_signal_parser_->pre ();

        return true;
      }

      if (n == "can_change_lane_left" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_left_parser_;

        if (this->can_change_lane_left_parser_)
          this->can_change_lane_left_parser_->pre ();

        return true;
      }

      if (n == "can_change_lane_right" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_right_parser_;

        if (this->can_change_lane_right_parser_)
          this->can_change_lane_right_parser_->pre ();

        return true;
      }

      if (n == "is_road_shoulder" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_road_shoulder_parser_;

        if (this->is_road_shoulder_parser_)
          this->is_road_shoulder_parser_->pre ();

        return true;
      }

      if (n == "is_bicycle_lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_bicycle_lane_parser_;

        if (this->is_bicycle_lane_parser_)
          this->is_bicycle_lane_parser_->pre ();

        return true;
      }

      if (n == "is_pedestrian_lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_pedestrian_lane_parser_;

        if (this->is_pedestrian_lane_parser_)
          this->is_pedestrian_lane_parser_->pre ();

        return true;
      }

      if (n == "is_vehicle_lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_vehicle_lane_parser_;

        if (this->is_vehicle_lane_parser_)
          this->is_vehicle_lane_parser_->pre ();

        return true;
      }

      if (n == "is_standard_bus_lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_standard_bus_lane_parser_;

        if (this->is_standard_bus_lane_parser_)
          this->is_standard_bus_lane_parser_->pre ();

        return true;
      }

      if (n == "is_whole_day_bus_lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_whole_day_bus_lane_parser_;

        if (this->is_whole_day_bus_lane_parser_)
          this->is_whole_day_bus_lane_parser_->pre ();

        return true;
      }

      if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_high_occupancy_vehicle_lane_parser_;

        if (this->is_high_occupancy_vehicle_lane_parser_)
          this->is_high_occupancy_vehicle_lane_parser_->pre ();

        return true;
      }

      if (n == "can_freely_park_here" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_freely_park_here_parser_;

        if (this->can_freely_park_here_parser_)
          this->can_freely_park_here_parser_->pre ();

        return true;
      }

      if (n == "can_stop_here" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->can_stop_here_parser_;

        if (this->can_stop_here_parser_)
          this->can_stop_here_parser_->pre ();

        return true;
      }

      if (n == "is_u_turn_allowed" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_u_turn_allowed_parser_;

        if (this->is_u_turn_allowed_parser_)
          this->is_u_turn_allowed_parser_->pre ();

        return true;
      }

      if (n == "PolyLine" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyLine_parser_;

        if (this->PolyLine_parser_)
          this->PolyLine_parser_->pre ();

        return true;
      }

      return false;
    }

    bool lane_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "laneID" && ns.empty ())
      {
        if (this->laneID_parser_)
          this->laneID (this->laneID_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "width" && ns.empty ())
      {
        if (this->width_parser_)
          this->width (this->width_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "can_go_straight" && ns.empty ())
      {
        if (this->can_go_straight_parser_)
          this->can_go_straight (this->can_go_straight_parser_->post_boolean ());

        return true;
      }

      if (n == "can_turn_left" && ns.empty ())
      {
        if (this->can_turn_left_parser_)
          this->can_turn_left (this->can_turn_left_parser_->post_boolean ());

        return true;
      }

      if (n == "can_turn_right" && ns.empty ())
      {
        if (this->can_turn_right_parser_)
          this->can_turn_right (this->can_turn_right_parser_->post_boolean ());

        return true;
      }

      if (n == "can_turn_on_red_signal" && ns.empty ())
      {
        if (this->can_turn_on_red_signal_parser_)
          this->can_turn_on_red_signal (this->can_turn_on_red_signal_parser_->post_boolean ());

        return true;
      }

      if (n == "can_change_lane_left" && ns.empty ())
      {
        if (this->can_change_lane_left_parser_)
          this->can_change_lane_left (this->can_change_lane_left_parser_->post_boolean ());

        return true;
      }

      if (n == "can_change_lane_right" && ns.empty ())
      {
        if (this->can_change_lane_right_parser_)
          this->can_change_lane_right (this->can_change_lane_right_parser_->post_boolean ());

        return true;
      }

      if (n == "is_road_shoulder" && ns.empty ())
      {
        if (this->is_road_shoulder_parser_)
          this->is_road_shoulder (this->is_road_shoulder_parser_->post_boolean ());

        return true;
      }

      if (n == "is_bicycle_lane" && ns.empty ())
      {
        if (this->is_bicycle_lane_parser_)
          this->is_bicycle_lane (this->is_bicycle_lane_parser_->post_boolean ());

        return true;
      }

      if (n == "is_pedestrian_lane" && ns.empty ())
      {
        if (this->is_pedestrian_lane_parser_)
          this->is_pedestrian_lane (this->is_pedestrian_lane_parser_->post_boolean ());

        return true;
      }

      if (n == "is_vehicle_lane" && ns.empty ())
      {
        if (this->is_vehicle_lane_parser_)
          this->is_vehicle_lane (this->is_vehicle_lane_parser_->post_boolean ());

        return true;
      }

      if (n == "is_standard_bus_lane" && ns.empty ())
      {
        if (this->is_standard_bus_lane_parser_)
          this->is_standard_bus_lane (this->is_standard_bus_lane_parser_->post_boolean ());

        return true;
      }

      if (n == "is_whole_day_bus_lane" && ns.empty ())
      {
        if (this->is_whole_day_bus_lane_parser_)
          this->is_whole_day_bus_lane (this->is_whole_day_bus_lane_parser_->post_boolean ());

        return true;
      }

      if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
      {
        if (this->is_high_occupancy_vehicle_lane_parser_)
          this->is_high_occupancy_vehicle_lane (this->is_high_occupancy_vehicle_lane_parser_->post_boolean ());

        return true;
      }

      if (n == "can_freely_park_here" && ns.empty ())
      {
        if (this->can_freely_park_here_parser_)
          this->can_freely_park_here (this->can_freely_park_here_parser_->post_boolean ());

        return true;
      }

      if (n == "can_stop_here" && ns.empty ())
      {
        if (this->can_stop_here_parser_)
          this->can_stop_here (this->can_stop_here_parser_->post_boolean ());

        return true;
      }

      if (n == "is_u_turn_allowed" && ns.empty ())
      {
        if (this->is_u_turn_allowed_parser_)
          this->is_u_turn_allowed (this->is_u_turn_allowed_parser_->post_boolean ());

        return true;
      }

      if (n == "PolyLine" && ns.empty ())
      {
        if (this->PolyLine_parser_)
          this->PolyLine (this->PolyLine_parser_->post_PolyLine_t ());

        return true;
      }

      return false;
    }

    // connector_t_pskel
    //

    void connector_t_pskel::
    laneFrom (unsigned long long)
    {
    }

    void connector_t_pskel::
    laneTo (unsigned long long)
    {
    }

    bool connector_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "laneFrom" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneFrom_parser_;

        if (this->laneFrom_parser_)
          this->laneFrom_parser_->pre ();

        return true;
      }

      if (n == "laneTo" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneTo_parser_;

        if (this->laneTo_parser_)
          this->laneTo_parser_->pre ();

        return true;
      }

      return false;
    }

    bool connector_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "laneFrom" && ns.empty ())
      {
        if (this->laneFrom_parser_)
          this->laneFrom (this->laneFrom_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "laneTo" && ns.empty ())
      {
        if (this->laneTo_parser_)
          this->laneTo (this->laneTo_parser_->post_unsigned_long ());

        return true;
      }

      return false;
    }

    // connectors_t_pskel
    //

    void connectors_t_pskel::
    Connector (std::pair<unsigned long,unsigned long>)
    {
    }

    bool connectors_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Connector" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Connector_parser_;

        if (this->Connector_parser_)
          this->Connector_parser_->pre ();

        return true;
      }

      return false;
    }

    bool connectors_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Connector" && ns.empty ())
      {
        if (this->Connector_parser_)
          this->Connector (this->Connector_parser_->post_connector_t ());

        return true;
      }

      return false;
    }

    // Multi_Connector_t_pskel
    //

    void Multi_Connector_t_pskel::
    RoadSegment (unsigned long long)
    {
    }

    void Multi_Connector_t_pskel::
    Connectors (std::set<std::pair<unsigned long,unsigned long> >)
    {
    }

    bool Multi_Connector_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "RoadSegment" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadSegment_parser_;

        if (this->RoadSegment_parser_)
          this->RoadSegment_parser_->pre ();

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

        if (this->Connectors_parser_)
          this->Connectors_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Multi_Connector_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "RoadSegment" && ns.empty ())
      {
        if (this->RoadSegment_parser_)
          this->RoadSegment (this->RoadSegment_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        if (this->Connectors_parser_)
          this->Connectors (this->Connectors_parser_->post_connectors_t ());

        return true;
      }

      return false;
    }

    // Multi_Connectors_t_pskel
    //

    void Multi_Connectors_t_pskel::
    MultiConnectors (const std::pair<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
    {
    }

    bool Multi_Connectors_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "MultiConnectors" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->MultiConnectors_parser_;

        if (this->MultiConnectors_parser_)
          this->MultiConnectors_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Multi_Connectors_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "MultiConnectors" && ns.empty ())
      {
        if (this->MultiConnectors_parser_)
          this->MultiConnectors (this->MultiConnectors_parser_->post_Multi_Connector_t ());

        return true;
      }

      return false;
    }

    // fwdBckSegments_t_pskel
    //

    void fwdBckSegments_t_pskel::
    Segment (sim_mob::RoadSegment*)
    {
    }

    bool fwdBckSegments_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Segment" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Segment_parser_;

        if (this->Segment_parser_)
          this->Segment_parser_->pre ();

        return true;
      }

      return false;
    }

    bool fwdBckSegments_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Segment" && ns.empty ())
      {
        if (this->Segment_parser_)
          this->Segment (this->Segment_parser_->post_segment_t ());

        return true;
      }

      return false;
    }

    // RoadSegmentsAt_t_pskel
    //

    void RoadSegmentsAt_t_pskel::
    segmentID (unsigned long long)
    {
    }

    bool RoadSegmentsAt_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "segmentID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

        if (this->segmentID_parser_)
          this->segmentID_parser_->pre ();

        return true;
      }

      return false;
    }

    bool RoadSegmentsAt_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "segmentID" && ns.empty ())
      {
        if (this->segmentID_parser_)
          this->segmentID (this->segmentID_parser_->post_unsigned_long ());

        return true;
      }

      return false;
    }

    // laneEdgePolyline_cached_t_pskel
    //

    void laneEdgePolyline_cached_t_pskel::
    laneNumber (short)
    {
    }

    void laneEdgePolyline_cached_t_pskel::
    polyline (std::vector<sim_mob::Point2D>)
    {
    }

    bool laneEdgePolyline_cached_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "laneNumber" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneNumber_parser_;

        if (this->laneNumber_parser_)
          this->laneNumber_parser_->pre ();

        return true;
      }

      if (n == "polyline" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->polyline_parser_;

        if (this->polyline_parser_)
          this->polyline_parser_->pre ();

        return true;
      }

      return false;
    }

    bool laneEdgePolyline_cached_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "laneNumber" && ns.empty ())
      {
        if (this->laneNumber_parser_)
          this->laneNumber (this->laneNumber_parser_->post_short ());

        return true;
      }

      if (n == "polyline" && ns.empty ())
      {
        if (this->polyline_parser_)
          this->polyline (this->polyline_parser_->post_PolyLine_t ());

        return true;
      }

      return false;
    }

    // laneEdgePolylines_cached_t_pskel
    //

    void laneEdgePolylines_cached_t_pskel::
    laneEdgePolyline_cached (std::pair<short,std::vector<sim_mob::Point2D> >)
    {
    }

    bool laneEdgePolylines_cached_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "laneEdgePolyline_cached" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneEdgePolyline_cached_parser_;

        if (this->laneEdgePolyline_cached_parser_)
          this->laneEdgePolyline_cached_parser_->pre ();

        return true;
      }

      return false;
    }

    bool laneEdgePolylines_cached_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "laneEdgePolyline_cached" && ns.empty ())
      {
        if (this->laneEdgePolyline_cached_parser_)
          this->laneEdgePolyline_cached (this->laneEdgePolyline_cached_parser_->post_laneEdgePolyline_cached_t ());

        return true;
      }

      return false;
    }

    // segment_t_pskel
    //

    void segment_t_pskel::
    segmentID (unsigned long long)
    {
    }

    void segment_t_pskel::
    startingNode (unsigned int)
    {
    }

    void segment_t_pskel::
    endingNode (unsigned int)
    {
    }

    void segment_t_pskel::
    maxSpeed (short)
    {
    }

    void segment_t_pskel::
    Length (unsigned int)
    {
    }

    void segment_t_pskel::
    Width (unsigned int)
    {
    }

    void segment_t_pskel::
    originalDB_ID (const ::std::string&)
    {
    }

    void segment_t_pskel::
    polyline (std::vector<sim_mob::Point2D>)
    {
    }

    void segment_t_pskel::
    laneEdgePolylines_cached (std::vector<std::vector<sim_mob::Point2D> >)
    {
    }

    void segment_t_pskel::
    Lanes (std::vector<sim_mob::Lane*>)
    {
    }

    void segment_t_pskel::
    Obstacles (std::map<sim_mob::centimeter_t,const RoadItem*>)
    {
    }

    void segment_t_pskel::
    KurbLine (std::vector<sim_mob::Point2D>)
    {
    }

    bool segment_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "segmentID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

        if (this->segmentID_parser_)
          this->segmentID_parser_->pre ();

        return true;
      }

      if (n == "startingNode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->startingNode_parser_;

        if (this->startingNode_parser_)
          this->startingNode_parser_->pre ();

        return true;
      }

      if (n == "endingNode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->endingNode_parser_;

        if (this->endingNode_parser_)
          this->endingNode_parser_->pre ();

        return true;
      }

      if (n == "maxSpeed" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->maxSpeed_parser_;

        if (this->maxSpeed_parser_)
          this->maxSpeed_parser_->pre ();

        return true;
      }

      if (n == "Length" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Length_parser_;

        if (this->Length_parser_)
          this->Length_parser_->pre ();

        return true;
      }

      if (n == "Width" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Width_parser_;

        if (this->Width_parser_)
          this->Width_parser_->pre ();

        return true;
      }

      if (n == "originalDB_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->originalDB_ID_parser_;

        if (this->originalDB_ID_parser_)
          this->originalDB_ID_parser_->pre ();

        return true;
      }

      if (n == "polyline" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->polyline_parser_;

        if (this->polyline_parser_)
          this->polyline_parser_->pre ();

        return true;
      }

      if (n == "laneEdgePolylines_cached" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneEdgePolylines_cached_parser_;

        if (this->laneEdgePolylines_cached_parser_)
          this->laneEdgePolylines_cached_parser_->pre ();

        return true;
      }

      if (n == "Lanes" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Lanes_parser_;

        if (this->Lanes_parser_)
          this->Lanes_parser_->pre ();

        return true;
      }

      if (n == "Obstacles" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Obstacles_parser_;

        if (this->Obstacles_parser_)
          this->Obstacles_parser_->pre ();

        return true;
      }

      if (n == "KurbLine" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->KurbLine_parser_;

        if (this->KurbLine_parser_)
          this->KurbLine_parser_->pre ();

        return true;
      }

      return false;
    }

    bool segment_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "segmentID" && ns.empty ())
      {
        if (this->segmentID_parser_)
          this->segmentID (this->segmentID_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "startingNode" && ns.empty ())
      {
        if (this->startingNode_parser_)
          this->startingNode (this->startingNode_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "endingNode" && ns.empty ())
      {
        if (this->endingNode_parser_)
          this->endingNode (this->endingNode_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "maxSpeed" && ns.empty ())
      {
        if (this->maxSpeed_parser_)
          this->maxSpeed (this->maxSpeed_parser_->post_short ());

        return true;
      }

      if (n == "Length" && ns.empty ())
      {
        if (this->Length_parser_)
          this->Length (this->Length_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "Width" && ns.empty ())
      {
        if (this->Width_parser_)
          this->Width (this->Width_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "originalDB_ID" && ns.empty ())
      {
        if (this->originalDB_ID_parser_)
          this->originalDB_ID (this->originalDB_ID_parser_->post_string ());

        return true;
      }

      if (n == "polyline" && ns.empty ())
      {
        if (this->polyline_parser_)
          this->polyline (this->polyline_parser_->post_PolyLine_t ());

        return true;
      }

      if (n == "laneEdgePolylines_cached" && ns.empty ())
      {
        if (this->laneEdgePolylines_cached_parser_)
          this->laneEdgePolylines_cached (this->laneEdgePolylines_cached_parser_->post_laneEdgePolylines_cached_t ());

        return true;
      }

      if (n == "Lanes" && ns.empty ())
      {
        if (this->Lanes_parser_)
          this->Lanes (this->Lanes_parser_->post_Lanes ());

        return true;
      }

      if (n == "Obstacles" && ns.empty ())
      {
        if (this->Obstacles_parser_)
          this->Obstacles (this->Obstacles_parser_->post_RoadItems_t ());

        return true;
      }

      if (n == "KurbLine" && ns.empty ())
      {
        if (this->KurbLine_parser_)
          this->KurbLine (this->KurbLine_parser_->post_PolyLine_t ());

        return true;
      }

      return false;
    }

    // link_t_pskel
    //

    void link_t_pskel::
    linkID (unsigned int)
    {
    }

    void link_t_pskel::
    roadName (const ::std::string&)
    {
    }

    void link_t_pskel::
    StartingNode (unsigned int)
    {
    }

    void link_t_pskel::
    EndingNode (unsigned int)
    {
    }

    void link_t_pskel::
    Segments (std::vector<sim_mob::RoadSegment*>)
    {
    }

    bool link_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "linkID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

        if (this->linkID_parser_)
          this->linkID_parser_->pre ();

        return true;
      }

      if (n == "roadName" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roadName_parser_;

        if (this->roadName_parser_)
          this->roadName_parser_->pre ();

        return true;
      }

      if (n == "StartingNode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->StartingNode_parser_;

        if (this->StartingNode_parser_)
          this->StartingNode_parser_->pre ();

        return true;
      }

      if (n == "EndingNode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->EndingNode_parser_;

        if (this->EndingNode_parser_)
          this->EndingNode_parser_->pre ();

        return true;
      }

      if (n == "Segments" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Segments_parser_;

        if (this->Segments_parser_)
          this->Segments_parser_->pre ();

        return true;
      }

      return false;
    }

    bool link_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "linkID" && ns.empty ())
      {
        if (this->linkID_parser_)
          this->linkID (this->linkID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "roadName" && ns.empty ())
      {
        if (this->roadName_parser_)
          this->roadName (this->roadName_parser_->post_string ());

        return true;
      }

      if (n == "StartingNode" && ns.empty ())
      {
        if (this->StartingNode_parser_)
          this->StartingNode (this->StartingNode_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "EndingNode" && ns.empty ())
      {
        if (this->EndingNode_parser_)
          this->EndingNode (this->EndingNode_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "Segments" && ns.empty ())
      {
        if (this->Segments_parser_)
          this->Segments (this->Segments_parser_->post_fwdBckSegments_t ());

        return true;
      }

      return false;
    }

    // separator_t_pskel
    //

    void separator_t_pskel::
    separator_ID (unsigned short)
    {
    }

    void separator_t_pskel::
    separator_value (bool)
    {
    }

    void separator_t_pskel::
    post_separator_t ()
    {
    }

    bool separator_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "separator_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_ID_parser_;

        if (this->separator_ID_parser_)
          this->separator_ID_parser_->pre ();

        return true;
      }

      if (n == "separator_value" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_value_parser_;

        if (this->separator_value_parser_)
          this->separator_value_parser_->pre ();

        return true;
      }

      return false;
    }

    bool separator_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "separator_ID" && ns.empty ())
      {
        if (this->separator_ID_parser_)
          this->separator_ID (this->separator_ID_parser_->post_unsigned_short ());

        return true;
      }

      if (n == "separator_value" && ns.empty ())
      {
        if (this->separator_value_parser_)
          this->separator_value (this->separator_value_parser_->post_boolean ());

        return true;
      }

      return false;
    }

    // separators_t_pskel
    //

    void separators_t_pskel::
    Separator ()
    {
    }

    void separators_t_pskel::
    post_separators_t ()
    {
    }

    bool separators_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Separator" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Separator_parser_;

        if (this->Separator_parser_)
          this->Separator_parser_->pre ();

        return true;
      }

      return false;
    }

    bool separators_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Separator" && ns.empty ())
      {
        if (this->Separator_parser_)
        {
          this->Separator_parser_->post_separator_t ();
          this->Separator ();
        }

        return true;
      }

      return false;
    }

    // DomainIsland_t_pskel
    //

    void DomainIsland_t_pskel::
    domainIsland_ID (unsigned short)
    {
    }

    void DomainIsland_t_pskel::
    domainIsland_value (bool)
    {
    }

    void DomainIsland_t_pskel::
    post_DomainIsland_t ()
    {
    }

    bool DomainIsland_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "domainIsland_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_ID_parser_;

        if (this->domainIsland_ID_parser_)
          this->domainIsland_ID_parser_->pre ();

        return true;
      }

      if (n == "domainIsland_value" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_value_parser_;

        if (this->domainIsland_value_parser_)
          this->domainIsland_value_parser_->pre ();

        return true;
      }

      return false;
    }

    bool DomainIsland_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "domainIsland_ID" && ns.empty ())
      {
        if (this->domainIsland_ID_parser_)
          this->domainIsland_ID (this->domainIsland_ID_parser_->post_unsigned_short ());

        return true;
      }

      if (n == "domainIsland_value" && ns.empty ())
      {
        if (this->domainIsland_value_parser_)
          this->domainIsland_value (this->domainIsland_value_parser_->post_boolean ());

        return true;
      }

      return false;
    }

    // DomainIslands_t_pskel
    //

    void DomainIslands_t_pskel::
    domainIslands ()
    {
    }

    void DomainIslands_t_pskel::
    post_DomainIslands_t ()
    {
    }

    bool DomainIslands_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "domainIslands" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

        if (this->domainIslands_parser_)
          this->domainIslands_parser_->pre ();

        return true;
      }

      return false;
    }

    bool DomainIslands_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "domainIslands" && ns.empty ())
      {
        if (this->domainIslands_parser_)
        {
          this->domainIslands_parser_->post_DomainIsland_t ();
          this->domainIslands ();
        }

        return true;
      }

      return false;
    }

    // offset_t_pskel
    //

    void offset_t_pskel::
    offset_ID (unsigned short)
    {
    }

    void offset_t_pskel::
    offset_value (unsigned int)
    {
    }

    void offset_t_pskel::
    post_offset_t ()
    {
    }

    bool offset_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "offset_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_ID_parser_;

        if (this->offset_ID_parser_)
          this->offset_ID_parser_->pre ();

        return true;
      }

      if (n == "offset_value" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_value_parser_;

        if (this->offset_value_parser_)
          this->offset_value_parser_->pre ();

        return true;
      }

      return false;
    }

    bool offset_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "offset_ID" && ns.empty ())
      {
        if (this->offset_ID_parser_)
          this->offset_ID (this->offset_ID_parser_->post_unsigned_short ());

        return true;
      }

      if (n == "offset_value" && ns.empty ())
      {
        if (this->offset_value_parser_)
          this->offset_value (this->offset_value_parser_->post_unsigned_int ());

        return true;
      }

      return false;
    }

    // offsets_t_pskel
    //

    void offsets_t_pskel::
    offset ()
    {
    }

    void offsets_t_pskel::
    post_offsets_t ()
    {
    }

    bool offsets_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "offset" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

        if (this->offset_parser_)
          this->offset_parser_->pre ();

        return true;
      }

      return false;
    }

    bool offsets_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "offset" && ns.empty ())
      {
        if (this->offset_parser_)
        {
          this->offset_parser_->post_offset_t ();
          this->offset ();
        }

        return true;
      }

      return false;
    }

    // ChunkLength_t_pskel
    //

    void ChunkLength_t_pskel::
    chunklength_ID (unsigned short)
    {
    }

    void ChunkLength_t_pskel::
    chunklength_value (unsigned int)
    {
    }

    void ChunkLength_t_pskel::
    post_ChunkLength_t ()
    {
    }

    bool ChunkLength_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "chunklength_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_ID_parser_;

        if (this->chunklength_ID_parser_)
          this->chunklength_ID_parser_->pre ();

        return true;
      }

      if (n == "chunklength_value" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_value_parser_;

        if (this->chunklength_value_parser_)
          this->chunklength_value_parser_->pre ();

        return true;
      }

      return false;
    }

    bool ChunkLength_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "chunklength_ID" && ns.empty ())
      {
        if (this->chunklength_ID_parser_)
          this->chunklength_ID (this->chunklength_ID_parser_->post_unsigned_short ());

        return true;
      }

      if (n == "chunklength_value" && ns.empty ())
      {
        if (this->chunklength_value_parser_)
          this->chunklength_value (this->chunklength_value_parser_->post_unsigned_int ());

        return true;
      }

      return false;
    }

    // ChunkLengths_t_pskel
    //

    void ChunkLengths_t_pskel::
    chunklength ()
    {
    }

    void ChunkLengths_t_pskel::
    post_ChunkLengths_t ()
    {
    }

    bool ChunkLengths_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "chunklength" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_parser_;

        if (this->chunklength_parser_)
          this->chunklength_parser_->pre ();

        return true;
      }

      return false;
    }

    bool ChunkLengths_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "chunklength" && ns.empty ())
      {
        if (this->chunklength_parser_)
        {
          this->chunklength_parser_->post_ChunkLength_t ();
          this->chunklength ();
        }

        return true;
      }

      return false;
    }

    // LanesVector_t_pskel
    //

    void LanesVector_t_pskel::
    laneID (unsigned long long)
    {
    }

    void LanesVector_t_pskel::
    post_LanesVector_t ()
    {
    }

    bool LanesVector_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "laneID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

        if (this->laneID_parser_)
          this->laneID_parser_->pre ();

        return true;
      }

      return false;
    }

    bool LanesVector_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "laneID" && ns.empty ())
      {
        if (this->laneID_parser_)
          this->laneID (this->laneID_parser_->post_unsigned_long ());

        return true;
      }

      return false;
    }

    // EntranceAngle_t_pskel
    //

    void EntranceAngle_t_pskel::
    entranceAngle_ID (unsigned short)
    {
    }

    void EntranceAngle_t_pskel::
    entranceAngle_value (unsigned int)
    {
    }

    void EntranceAngle_t_pskel::
    post_EntranceAngle_t ()
    {
    }

    bool EntranceAngle_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "entranceAngle_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_ID_parser_;

        if (this->entranceAngle_ID_parser_)
          this->entranceAngle_ID_parser_->pre ();

        return true;
      }

      if (n == "entranceAngle_value" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_value_parser_;

        if (this->entranceAngle_value_parser_)
          this->entranceAngle_value_parser_->pre ();

        return true;
      }

      return false;
    }

    bool EntranceAngle_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "entranceAngle_ID" && ns.empty ())
      {
        if (this->entranceAngle_ID_parser_)
          this->entranceAngle_ID (this->entranceAngle_ID_parser_->post_unsigned_short ());

        return true;
      }

      if (n == "entranceAngle_value" && ns.empty ())
      {
        if (this->entranceAngle_value_parser_)
          this->entranceAngle_value (this->entranceAngle_value_parser_->post_unsigned_int ());

        return true;
      }

      return false;
    }

    // EntranceAngles_t_pskel
    //

    void EntranceAngles_t_pskel::
    entranceAngle ()
    {
    }

    void EntranceAngles_t_pskel::
    post_EntranceAngles_t ()
    {
    }

    bool EntranceAngles_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "entranceAngle" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_parser_;

        if (this->entranceAngle_parser_)
          this->entranceAngle_parser_->pre ();

        return true;
      }

      return false;
    }

    bool EntranceAngles_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "entranceAngle" && ns.empty ())
      {
        if (this->entranceAngle_parser_)
        {
          this->entranceAngle_parser_->post_EntranceAngle_t ();
          this->entranceAngle ();
        }

        return true;
      }

      return false;
    }

    // Node_t_pskel
    //

    void Node_t_pskel::
    nodeID (unsigned int)
    {
    }

    void Node_t_pskel::
    location (sim_mob::Point2D)
    {
    }

    void Node_t_pskel::
    originalDB_ID (const ::std::string&)
    {
    }

    bool Node_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "nodeID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

        if (this->nodeID_parser_)
          this->nodeID_parser_->pre ();

        return true;
      }

      if (n == "location" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

        if (this->location_parser_)
          this->location_parser_->pre ();

        return true;
      }

      if (n == "originalDB_ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->originalDB_ID_parser_;

        if (this->originalDB_ID_parser_)
          this->originalDB_ID_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Node_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "nodeID" && ns.empty ())
      {
        if (this->nodeID_parser_)
          this->nodeID (this->nodeID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "location" && ns.empty ())
      {
        if (this->location_parser_)
          this->location (this->location_parser_->post_Point2D_t ());

        return true;
      }

      if (n == "originalDB_ID" && ns.empty ())
      {
        if (this->originalDB_ID_parser_)
          this->originalDB_ID (this->originalDB_ID_parser_->post_string ());

        return true;
      }

      return false;
    }

    // temp_Segmetair_t_pskel
    //

    void temp_Segmetair_t_pskel::
    first (unsigned long long)
    {
    }

    void temp_Segmetair_t_pskel::
    second (unsigned long long)
    {
    }

    bool temp_Segmetair_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "first" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

        if (this->first_parser_)
          this->first_parser_->pre ();

        return true;
      }

      if (n == "second" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

        if (this->second_parser_)
          this->second_parser_->pre ();

        return true;
      }

      return false;
    }

    bool temp_Segmetair_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "first" && ns.empty ())
      {
        if (this->first_parser_)
          this->first (this->first_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "second" && ns.empty ())
      {
        if (this->second_parser_)
          this->second (this->second_parser_->post_unsigned_long ());

        return true;
      }

      return false;
    }

    // UniNode_t_pskel
    //

    void UniNode_t_pskel::
    firstPair (std::pair<unsigned long,unsigned long>)
    {
    }

    void UniNode_t_pskel::
    secondPair (std::pair<unsigned long,unsigned long>)
    {
    }

    void UniNode_t_pskel::
    Connectors (std::set<std::pair<unsigned long,unsigned long> >)
    {
    }

    bool UniNode_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::Node_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "firstPair" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->firstPair_parser_;

        if (this->firstPair_parser_)
          this->firstPair_parser_->pre ();

        return true;
      }

      if (n == "secondPair" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->secondPair_parser_;

        if (this->secondPair_parser_)
          this->secondPair_parser_->pre ();

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

        if (this->Connectors_parser_)
          this->Connectors_parser_->pre ();

        return true;
      }

      return false;
    }

    bool UniNode_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::Node_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "firstPair" && ns.empty ())
      {
        if (this->firstPair_parser_)
          this->firstPair (this->firstPair_parser_->post_temp_Segmetair_t ());

        return true;
      }

      if (n == "secondPair" && ns.empty ())
      {
        if (this->secondPair_parser_)
          this->secondPair (this->secondPair_parser_->post_temp_Segmetair_t ());

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        if (this->Connectors_parser_)
          this->Connectors (this->Connectors_parser_->post_connectors_t ());

        return true;
      }

      return false;
    }

    // roundabout_t_pskel
    //

    void roundabout_t_pskel::
    roadSegmentsAt (std::set<unsigned long>)
    {
    }

    void roundabout_t_pskel::
    Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
    {
    }

    void roundabout_t_pskel::
    ChunkLengths ()
    {
    }

    void roundabout_t_pskel::
    Offsets ()
    {
    }

    void roundabout_t_pskel::
    Separators ()
    {
    }

    void roundabout_t_pskel::
    addDominantLane ()
    {
    }

    void roundabout_t_pskel::
    roundaboutDominantIslands (float)
    {
    }

    void roundabout_t_pskel::
    roundaboutNumberOfLanes (int)
    {
    }

    void roundabout_t_pskel::
    entranceAngles ()
    {
    }

    bool roundabout_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::Node_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "roadSegmentsAt" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

        if (this->roadSegmentsAt_parser_)
          this->roadSegmentsAt_parser_->pre ();

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

        if (this->Connectors_parser_)
          this->Connectors_parser_->pre ();

        return true;
      }

      if (n == "ChunkLengths" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

        if (this->ChunkLengths_parser_)
          this->ChunkLengths_parser_->pre ();

        return true;
      }

      if (n == "Offsets" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

        if (this->Offsets_parser_)
          this->Offsets_parser_->pre ();

        return true;
      }

      if (n == "Separators" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

        if (this->Separators_parser_)
          this->Separators_parser_->pre ();

        return true;
      }

      if (n == "addDominantLane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->addDominantLane_parser_;

        if (this->addDominantLane_parser_)
          this->addDominantLane_parser_->pre ();

        return true;
      }

      if (n == "roundaboutDominantIslands" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutDominantIslands_parser_;

        if (this->roundaboutDominantIslands_parser_)
          this->roundaboutDominantIslands_parser_->pre ();

        return true;
      }

      if (n == "roundaboutNumberOfLanes" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutNumberOfLanes_parser_;

        if (this->roundaboutNumberOfLanes_parser_)
          this->roundaboutNumberOfLanes_parser_->pre ();

        return true;
      }

      if (n == "entranceAngles" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngles_parser_;

        if (this->entranceAngles_parser_)
          this->entranceAngles_parser_->pre ();

        return true;
      }

      return false;
    }

    bool roundabout_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::Node_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "roadSegmentsAt" && ns.empty ())
      {
        if (this->roadSegmentsAt_parser_)
          this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        if (this->Connectors_parser_)
          this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

        return true;
      }

      if (n == "ChunkLengths" && ns.empty ())
      {
        if (this->ChunkLengths_parser_)
        {
          this->ChunkLengths_parser_->post_ChunkLengths_t ();
          this->ChunkLengths ();
        }

        return true;
      }

      if (n == "Offsets" && ns.empty ())
      {
        if (this->Offsets_parser_)
        {
          this->Offsets_parser_->post_offsets_t ();
          this->Offsets ();
        }

        return true;
      }

      if (n == "Separators" && ns.empty ())
      {
        if (this->Separators_parser_)
        {
          this->Separators_parser_->post_separators_t ();
          this->Separators ();
        }

        return true;
      }

      if (n == "addDominantLane" && ns.empty ())
      {
        if (this->addDominantLane_parser_)
        {
          this->addDominantLane_parser_->post_LanesVector_t ();
          this->addDominantLane ();
        }

        return true;
      }

      if (n == "roundaboutDominantIslands" && ns.empty ())
      {
        if (this->roundaboutDominantIslands_parser_)
          this->roundaboutDominantIslands (this->roundaboutDominantIslands_parser_->post_float ());

        return true;
      }

      if (n == "roundaboutNumberOfLanes" && ns.empty ())
      {
        if (this->roundaboutNumberOfLanes_parser_)
          this->roundaboutNumberOfLanes (this->roundaboutNumberOfLanes_parser_->post_int ());

        return true;
      }

      if (n == "entranceAngles" && ns.empty ())
      {
        if (this->entranceAngles_parser_)
        {
          this->entranceAngles_parser_->post_EntranceAngles_t ();
          this->entranceAngles ();
        }

        return true;
      }

      return false;
    }

    // intersection_t_pskel
    //

    void intersection_t_pskel::
    roadSegmentsAt (std::set<unsigned long>)
    {
    }

    void intersection_t_pskel::
    Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
    {
    }

    void intersection_t_pskel::
    ChunkLengths ()
    {
    }

    void intersection_t_pskel::
    Offsets ()
    {
    }

    void intersection_t_pskel::
    Separators ()
    {
    }

    void intersection_t_pskel::
    additionalDominantLanes ()
    {
    }

    void intersection_t_pskel::
    additionalSubdominantLanes ()
    {
    }

    void intersection_t_pskel::
    domainIslands ()
    {
    }

    bool intersection_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::Node_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "roadSegmentsAt" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

        if (this->roadSegmentsAt_parser_)
          this->roadSegmentsAt_parser_->pre ();

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

        if (this->Connectors_parser_)
          this->Connectors_parser_->pre ();

        return true;
      }

      if (n == "ChunkLengths" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

        if (this->ChunkLengths_parser_)
          this->ChunkLengths_parser_->pre ();

        return true;
      }

      if (n == "Offsets" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

        if (this->Offsets_parser_)
          this->Offsets_parser_->pre ();

        return true;
      }

      if (n == "Separators" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

        if (this->Separators_parser_)
          this->Separators_parser_->pre ();

        return true;
      }

      if (n == "additionalDominantLanes" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalDominantLanes_parser_;

        if (this->additionalDominantLanes_parser_)
          this->additionalDominantLanes_parser_->pre ();

        return true;
      }

      if (n == "additionalSubdominantLanes" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalSubdominantLanes_parser_;

        if (this->additionalSubdominantLanes_parser_)
          this->additionalSubdominantLanes_parser_->pre ();

        return true;
      }

      if (n == "domainIslands" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

        if (this->domainIslands_parser_)
          this->domainIslands_parser_->pre ();

        return true;
      }

      return false;
    }

    bool intersection_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::Node_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "roadSegmentsAt" && ns.empty ())
      {
        if (this->roadSegmentsAt_parser_)
          this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

        return true;
      }

      if (n == "Connectors" && ns.empty ())
      {
        if (this->Connectors_parser_)
          this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

        return true;
      }

      if (n == "ChunkLengths" && ns.empty ())
      {
        if (this->ChunkLengths_parser_)
        {
          this->ChunkLengths_parser_->post_ChunkLengths_t ();
          this->ChunkLengths ();
        }

        return true;
      }

      if (n == "Offsets" && ns.empty ())
      {
        if (this->Offsets_parser_)
        {
          this->Offsets_parser_->post_offsets_t ();
          this->Offsets ();
        }

        return true;
      }

      if (n == "Separators" && ns.empty ())
      {
        if (this->Separators_parser_)
        {
          this->Separators_parser_->post_separators_t ();
          this->Separators ();
        }

        return true;
      }

      if (n == "additionalDominantLanes" && ns.empty ())
      {
        if (this->additionalDominantLanes_parser_)
        {
          this->additionalDominantLanes_parser_->post_LanesVector_t ();
          this->additionalDominantLanes ();
        }

        return true;
      }

      if (n == "additionalSubdominantLanes" && ns.empty ())
      {
        if (this->additionalSubdominantLanes_parser_)
        {
          this->additionalSubdominantLanes_parser_->post_LanesVector_t ();
          this->additionalSubdominantLanes ();
        }

        return true;
      }

      if (n == "domainIslands" && ns.empty ())
      {
        if (this->domainIslands_parser_)
        {
          this->domainIslands_parser_->post_DomainIslands_t ();
          this->domainIslands ();
        }

        return true;
      }

      return false;
    }

    // RoadItem_t_pskel
    //

    void RoadItem_t_pskel::
    id (unsigned long long)
    {
    }

    void RoadItem_t_pskel::
    Offset (unsigned short)
    {
    }

    void RoadItem_t_pskel::
    start (sim_mob::Point2D)
    {
    }

    void RoadItem_t_pskel::
    end (sim_mob::Point2D)
    {
    }

    bool RoadItem_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "id" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->id_parser_;

        if (this->id_parser_)
          this->id_parser_->pre ();

        return true;
      }

      if (n == "Offset" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Offset_parser_;

        if (this->Offset_parser_)
          this->Offset_parser_->pre ();

        return true;
      }

      if (n == "start" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->start_parser_;

        if (this->start_parser_)
          this->start_parser_->pre ();

        return true;
      }

      if (n == "end" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->end_parser_;

        if (this->end_parser_)
          this->end_parser_->pre ();

        return true;
      }

      return false;
    }

    bool RoadItem_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "id" && ns.empty ())
      {
        if (this->id_parser_)
          this->id (this->id_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "Offset" && ns.empty ())
      {
        if (this->Offset_parser_)
          this->Offset (this->Offset_parser_->post_unsigned_short ());

        return true;
      }

      if (n == "start" && ns.empty ())
      {
        if (this->start_parser_)
          this->start (this->start_parser_->post_Point2D_t ());

        return true;
      }

      if (n == "end" && ns.empty ())
      {
        if (this->end_parser_)
          this->end (this->end_parser_->post_Point2D_t ());

        return true;
      }

      return false;
    }

    // BusStop_t_pskel
    //

    void BusStop_t_pskel::
    xPos (double)
    {
    }

    void BusStop_t_pskel::
    yPos (double)
    {
    }

    void BusStop_t_pskel::
    lane_location (unsigned long long)
    {
    }

    void BusStop_t_pskel::
    is_terminal (bool)
    {
    }

    void BusStop_t_pskel::
    is_bay (bool)
    {
    }

    void BusStop_t_pskel::
    has_shelter (bool)
    {
    }

    void BusStop_t_pskel::
    busCapacityAsLength (unsigned int)
    {
    }

    void BusStop_t_pskel::
    busstopno (const ::std::string&)
    {
    }

    bool BusStop_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "xPos" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->xPos_parser_;

        if (this->xPos_parser_)
          this->xPos_parser_->pre ();

        return true;
      }

      if (n == "yPos" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->yPos_parser_;

        if (this->yPos_parser_)
          this->yPos_parser_->pre ();

        return true;
      }

      if (n == "lane_location" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->lane_location_parser_;

        if (this->lane_location_parser_)
          this->lane_location_parser_->pre ();

        return true;
      }

      if (n == "is_terminal" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_terminal_parser_;

        if (this->is_terminal_parser_)
          this->is_terminal_parser_->pre ();

        return true;
      }

      if (n == "is_bay" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->is_bay_parser_;

        if (this->is_bay_parser_)
          this->is_bay_parser_->pre ();

        return true;
      }

      if (n == "has_shelter" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->has_shelter_parser_;

        if (this->has_shelter_parser_)
          this->has_shelter_parser_->pre ();

        return true;
      }

      if (n == "busCapacityAsLength" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->busCapacityAsLength_parser_;

        if (this->busCapacityAsLength_parser_)
          this->busCapacityAsLength_parser_->pre ();

        return true;
      }

      if (n == "busstopno" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->busstopno_parser_;

        if (this->busstopno_parser_)
          this->busstopno_parser_->pre ();

        return true;
      }

      return false;
    }

    bool BusStop_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "xPos" && ns.empty ())
      {
        if (this->xPos_parser_)
          this->xPos (this->xPos_parser_->post_double ());

        return true;
      }

      if (n == "yPos" && ns.empty ())
      {
        if (this->yPos_parser_)
          this->yPos (this->yPos_parser_->post_double ());

        return true;
      }

      if (n == "lane_location" && ns.empty ())
      {
        if (this->lane_location_parser_)
          this->lane_location (this->lane_location_parser_->post_unsigned_long ());

        return true;
      }

      if (n == "is_terminal" && ns.empty ())
      {
        if (this->is_terminal_parser_)
          this->is_terminal (this->is_terminal_parser_->post_boolean ());

        return true;
      }

      if (n == "is_bay" && ns.empty ())
      {
        if (this->is_bay_parser_)
          this->is_bay (this->is_bay_parser_->post_boolean ());

        return true;
      }

      if (n == "has_shelter" && ns.empty ())
      {
        if (this->has_shelter_parser_)
          this->has_shelter (this->has_shelter_parser_->post_boolean ());

        return true;
      }

      if (n == "busCapacityAsLength" && ns.empty ())
      {
        if (this->busCapacityAsLength_parser_)
          this->busCapacityAsLength (this->busCapacityAsLength_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "busstopno" && ns.empty ())
      {
        if (this->busstopno_parser_)
          this->busstopno (this->busstopno_parser_->post_string ());

        return true;
      }

      return false;
    }

    // ERP_Gantry_t_pskel
    //

    void ERP_Gantry_t_pskel::
    ERP_GantryID (const ::std::string&)
    {
    }

    void ERP_Gantry_t_pskel::
    post_ERP_Gantry_t ()
    {
    }

    bool ERP_Gantry_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "ERP_GantryID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_GantryID_parser_;

        if (this->ERP_GantryID_parser_)
          this->ERP_GantryID_parser_->pre ();

        return true;
      }

      return false;
    }

    bool ERP_Gantry_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "ERP_GantryID" && ns.empty ())
      {
        if (this->ERP_GantryID_parser_)
          this->ERP_GantryID (this->ERP_GantryID_parser_->post_string ());

        return true;
      }

      return false;
    }

    // FormType_pskel
    //

    void FormType_pskel::
    TextBox (int)
    {
    }

    void FormType_pskel::
    TextArea (int)
    {
    }

    void FormType_pskel::
    Header (int)
    {
    }

    void FormType_pskel::
    post_FormType ()
    {
    }

    bool FormType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "TextBox" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TextBox_parser_;

        if (this->TextBox_parser_)
          this->TextBox_parser_->pre ();

        return true;
      }

      if (n == "TextArea" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TextArea_parser_;

        if (this->TextArea_parser_)
          this->TextArea_parser_->pre ();

        return true;
      }

      if (n == "Header" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Header_parser_;

        if (this->Header_parser_)
          this->Header_parser_->pre ();

        return true;
      }

      return false;
    }

    bool FormType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "TextBox" && ns.empty ())
      {
        if (this->TextBox_parser_)
          this->TextBox (this->TextBox_parser_->post_int ());

        return true;
      }

      if (n == "TextArea" && ns.empty ())
      {
        if (this->TextArea_parser_)
          this->TextArea (this->TextArea_parser_->post_int ());

        return true;
      }

      if (n == "Header" && ns.empty ())
      {
        if (this->Header_parser_)
          this->Header (this->Header_parser_->post_int ());

        return true;
      }

      return false;
    }

    // PointPair_t_pskel
    //

    void PointPair_t_pskel::
    first (sim_mob::Point2D)
    {
    }

    void PointPair_t_pskel::
    second (sim_mob::Point2D)
    {
    }

    bool PointPair_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "first" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

        if (this->first_parser_)
          this->first_parser_->pre ();

        return true;
      }

      if (n == "second" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

        if (this->second_parser_)
          this->second_parser_->pre ();

        return true;
      }

      return false;
    }

    bool PointPair_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "first" && ns.empty ())
      {
        if (this->first_parser_)
          this->first (this->first_parser_->post_Point2D_t ());

        return true;
      }

      if (n == "second" && ns.empty ())
      {
        if (this->second_parser_)
          this->second (this->second_parser_->post_Point2D_t ());

        return true;
      }

      return false;
    }

    // crossing_t_pskel
    //

    void crossing_t_pskel::
    nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
    {
    }

    void crossing_t_pskel::
    farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
    {
    }

    bool crossing_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "nearLine" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->nearLine_parser_;

        if (this->nearLine_parser_)
          this->nearLine_parser_->pre ();

        return true;
      }

      if (n == "farLine" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->farLine_parser_;

        if (this->farLine_parser_)
          this->farLine_parser_->pre ();

        return true;
      }

      return false;
    }

    bool crossing_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "nearLine" && ns.empty ())
      {
        if (this->nearLine_parser_)
          this->nearLine (this->nearLine_parser_->post_PointPair_t ());

        return true;
      }

      if (n == "farLine" && ns.empty ())
      {
        if (this->farLine_parser_)
          this->farLine (this->farLine_parser_->post_PointPair_t ());

        return true;
      }

      return false;
    }

    // RoadBump_t_pskel
    //

    void RoadBump_t_pskel::
    roadBumpID (const ::std::string&)
    {
    }

    void RoadBump_t_pskel::
    segmentID (unsigned long long)
    {
    }

    void RoadBump_t_pskel::
    post_RoadBump_t ()
    {
    }

    bool RoadBump_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "roadBumpID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roadBumpID_parser_;

        if (this->roadBumpID_parser_)
          this->roadBumpID_parser_->pre ();

        return true;
      }

      if (n == "segmentID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

        if (this->segmentID_parser_)
          this->segmentID_parser_->pre ();

        return true;
      }

      return false;
    }

    bool RoadBump_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "roadBumpID" && ns.empty ())
      {
        if (this->roadBumpID_parser_)
          this->roadBumpID (this->roadBumpID_parser_->post_string ());

        return true;
      }

      if (n == "segmentID" && ns.empty ())
      {
        if (this->segmentID_parser_)
          this->segmentID (this->segmentID_parser_->post_unsigned_long ());

        return true;
      }

      return false;
    }

    // RoadNetwork_t_pskel
    //

    void RoadNetwork_t_pskel::
    Nodes (const helper::NodesRes&)
    {
    }

    void RoadNetwork_t_pskel::
    Links (const std::vector<sim_mob::Link*>&)
    {
    }

    bool RoadNetwork_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Nodes" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Nodes_parser_;

        if (this->Nodes_parser_)
          this->Nodes_parser_->pre ();

        return true;
      }

      if (n == "Links" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Links_parser_;

        if (this->Links_parser_)
          this->Links_parser_->pre ();

        return true;
      }

      return false;
    }

    bool RoadNetwork_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Nodes" && ns.empty ())
      {
        if (this->Nodes_parser_)
          this->Nodes (this->Nodes_parser_->post_Nodes ());

        return true;
      }

      if (n == "Links" && ns.empty ())
      {
        if (this->Links_parser_)
          this->Links (this->Links_parser_->post_Links ());

        return true;
      }

      return false;
    }

    // RoadItems_t_pskel
    //

    void RoadItems_t_pskel::
    BusStop (std::pair<unsigned long,sim_mob::BusStop*>)
    {
    }

    void RoadItems_t_pskel::
    ERP_Gantry ()
    {
    }

    void RoadItems_t_pskel::
    Crossing (std::pair<unsigned long,sim_mob::Crossing*>)
    {
    }

    void RoadItems_t_pskel::
    RoadBump ()
    {
    }

    bool RoadItems_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "BusStop" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->BusStop_parser_;

        if (this->BusStop_parser_)
          this->BusStop_parser_->pre ();

        return true;
      }

      if (n == "ERP_Gantry" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_Gantry_parser_;

        if (this->ERP_Gantry_parser_)
          this->ERP_Gantry_parser_->pre ();

        return true;
      }

      if (n == "Crossing" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Crossing_parser_;

        if (this->Crossing_parser_)
          this->Crossing_parser_->pre ();

        return true;
      }

      if (n == "RoadBump" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadBump_parser_;

        if (this->RoadBump_parser_)
          this->RoadBump_parser_->pre ();

        return true;
      }

      return false;
    }

    bool RoadItems_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "BusStop" && ns.empty ())
      {
        if (this->BusStop_parser_)
          this->BusStop (this->BusStop_parser_->post_BusStop_t ());

        return true;
      }

      if (n == "ERP_Gantry" && ns.empty ())
      {
        if (this->ERP_Gantry_parser_)
        {
          this->ERP_Gantry_parser_->post_ERP_Gantry_t ();
          this->ERP_Gantry ();
        }

        return true;
      }

      if (n == "Crossing" && ns.empty ())
      {
        if (this->Crossing_parser_)
          this->Crossing (this->Crossing_parser_->post_crossing_t ());

        return true;
      }

      if (n == "RoadBump" && ns.empty ())
      {
        if (this->RoadBump_parser_)
        {
          this->RoadBump_parser_->post_RoadBump_t ();
          this->RoadBump ();
        }

        return true;
      }

      return false;
    }

    // TripChainItem_t_pskel
    //

    void TripChainItem_t_pskel::
    personID (const ::std::string&)
    {
    }

    void TripChainItem_t_pskel::
    itemType (std::string)
    {
    }

    void TripChainItem_t_pskel::
    sequenceNumber (unsigned int)
    {
    }

    void TripChainItem_t_pskel::
    requestTime (long long)
    {
    }

    void TripChainItem_t_pskel::
    startTime (const ::std::string&)
    {
    }

    void TripChainItem_t_pskel::
    endTime (const ::std::string&)
    {
    }

    bool TripChainItem_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "personID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

        if (this->personID_parser_)
          this->personID_parser_->pre ();

        return true;
      }

      if (n == "itemType" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->itemType_parser_;

        if (this->itemType_parser_)
          this->itemType_parser_->pre ();

        return true;
      }

      if (n == "sequenceNumber" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->sequenceNumber_parser_;

        if (this->sequenceNumber_parser_)
          this->sequenceNumber_parser_->pre ();

        return true;
      }

      if (n == "requestTime" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->requestTime_parser_;

        if (this->requestTime_parser_)
          this->requestTime_parser_->pre ();

        return true;
      }

      if (n == "startTime" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->startTime_parser_;

        if (this->startTime_parser_)
          this->startTime_parser_->pre ();

        return true;
      }

      if (n == "endTime" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->endTime_parser_;

        if (this->endTime_parser_)
          this->endTime_parser_->pre ();

        return true;
      }

      return false;
    }

    bool TripChainItem_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "personID" && ns.empty ())
      {
        if (this->personID_parser_)
          this->personID (this->personID_parser_->post_string ());

        return true;
      }

      if (n == "itemType" && ns.empty ())
      {
        if (this->itemType_parser_)
          this->itemType (this->itemType_parser_->post_TripchainItemType ());

        return true;
      }

      if (n == "sequenceNumber" && ns.empty ())
      {
        if (this->sequenceNumber_parser_)
          this->sequenceNumber (this->sequenceNumber_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "requestTime" && ns.empty ())
      {
        if (this->requestTime_parser_){
        	long long val = this->requestTime_parser_->post_integer ();
        	std::cout << val << std::endl;
          this->requestTime (val);
        }

        return true;
      }

      if (n == "startTime" && ns.empty ())
      {
        if (this->startTime_parser_)
          this->startTime (this->startTime_parser_->post_string ());

        return true;
      }

      if (n == "endTime" && ns.empty ())
      {
        if (this->endTime_parser_)
          this->endTime (this->endTime_parser_->post_string ());

        return true;
      }

      return false;
    }

    // Trip_t_pskel
    //

    void Trip_t_pskel::
    tripID (long long)
    {
    }

    void Trip_t_pskel::
    fromLocation (unsigned int)
    {
    }

    void Trip_t_pskel::
    fromLocationType (std::string)
    {
    }

    void Trip_t_pskel::
    toLocation (unsigned int)
    {
    }

    void Trip_t_pskel::
    toLocationType (std::string)
    {
    }

    void Trip_t_pskel::
    subTrips (std::vector<sim_mob::SubTrip>)
    {
    }

    sim_mob::TripChainItem* Trip_t_pskel::
    post_Trip_t ()
    {
      return post_TripChainItem_t ();
    }

    bool Trip_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "tripID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->tripID_parser_;

        if (this->tripID_parser_)
          this->tripID_parser_->pre ();

        return true;
      }

      if (n == "fromLocation" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocation_parser_;

        if (this->fromLocation_parser_)
          this->fromLocation_parser_->pre ();

        return true;
      }

      if (n == "fromLocationType" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocationType_parser_;

        if (this->fromLocationType_parser_)
          this->fromLocationType_parser_->pre ();

        return true;
      }

      if (n == "toLocation" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocation_parser_;

        if (this->toLocation_parser_)
          this->toLocation_parser_->pre ();

        return true;
      }

      if (n == "toLocationType" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocationType_parser_;

        if (this->toLocationType_parser_)
          this->toLocationType_parser_->pre ();

        return true;
      }

      if (n == "subTrips" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->subTrips_parser_;

        if (this->subTrips_parser_)
          this->subTrips_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Trip_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::TripChainItem_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "tripID" && ns.empty ())
      {
        if (this->tripID_parser_)
          this->tripID (this->tripID_parser_->post_integer ());

        return true;
      }

      if (n == "fromLocation" && ns.empty ())
      {
        if (this->fromLocation_parser_)
          this->fromLocation (this->fromLocation_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "fromLocationType" && ns.empty ())
      {
        if (this->fromLocationType_parser_)
          this->fromLocationType (this->fromLocationType_parser_->post_TripchainItemLocationType ());

        return true;
      }

      if (n == "toLocation" && ns.empty ())
      {
        if (this->toLocation_parser_)
          this->toLocation (this->toLocation_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "toLocationType" && ns.empty ())
      {
        if (this->toLocationType_parser_)
          this->toLocationType (this->toLocationType_parser_->post_TripchainItemLocationType ());

        return true;
      }

      if (n == "subTrips" && ns.empty ())
      {
        if (this->subTrips_parser_)
          this->subTrips (this->subTrips_parser_->post_SubTrips_t ());

        return true;
      }

      return false;
    }

    // SubTrip_t_pskel
    //

    void SubTrip_t_pskel::
    mode (const ::std::string&)
    {
    }

    void SubTrip_t_pskel::
    isPrimaryMode (bool)
    {
    }

    void SubTrip_t_pskel::
    ptLineId (const ::std::string&)
    {
    }

    bool SubTrip_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::Trip_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "mode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->mode_parser_;

        if (this->mode_parser_)
          this->mode_parser_->pre ();

        return true;
      }

      if (n == "isPrimaryMode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimaryMode_parser_;

        if (this->isPrimaryMode_parser_)
          this->isPrimaryMode_parser_->pre ();

        return true;
      }

      if (n == "ptLineId" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ptLineId_parser_;

        if (this->ptLineId_parser_)
          this->ptLineId_parser_->pre ();

        return true;
      }

      return false;
    }

    bool SubTrip_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::Trip_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "mode" && ns.empty ())
      {
        if (this->mode_parser_)
          this->mode (this->mode_parser_->post_string ());

        return true;
      }

      if (n == "isPrimaryMode" && ns.empty ())
      {
        if (this->isPrimaryMode_parser_)
          this->isPrimaryMode (this->isPrimaryMode_parser_->post_boolean ());

        return true;
      }

      if (n == "ptLineId" && ns.empty ())
      {
        if (this->ptLineId_parser_)
          this->ptLineId (this->ptLineId_parser_->post_string ());

        return true;
      }

      return false;
    }

    // SubTrips_t_pskel
    //

    void SubTrips_t_pskel::
    subTrip (sim_mob::SubTrip)
    {
    }

    bool SubTrips_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "subTrip" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->subTrip_parser_;

        if (this->subTrip_parser_)
          this->subTrip_parser_->pre ();

        return true;
      }

      return false;
    }

    bool SubTrips_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "subTrip" && ns.empty ())
      {
        if (this->subTrip_parser_)
          this->subTrip (this->subTrip_parser_->post_SubTrip_t ());

        return true;
      }

      return false;
    }

    // Activity_t_pskel
    //

    void Activity_t_pskel::
    description (const ::std::string&)
    {
    }

    void Activity_t_pskel::
    location (unsigned int)
    {
    }

    void Activity_t_pskel::
    locationType (std::string)
    {
    }

    void Activity_t_pskel::
    isPrimary (bool)
    {
    }

    void Activity_t_pskel::
    isFlexible (bool)
    {
    }

    void Activity_t_pskel::
    isMandatory (bool)
    {
    }

    sim_mob::TripChainItem* Activity_t_pskel::
    post_Activity_t ()
    {
      return post_TripChainItem_t ();
    }

    bool Activity_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::sim_mob::xml::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
        return true;

      if (n == "description" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

        if (this->description_parser_)
          this->description_parser_->pre ();

        return true;
      }

      if (n == "location" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

        if (this->location_parser_)
          this->location_parser_->pre ();

        return true;
      }

      if (n == "locationType" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->locationType_parser_;

        if (this->locationType_parser_)
          this->locationType_parser_->pre ();

        return true;
      }

      if (n == "isPrimary" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimary_parser_;

        if (this->isPrimary_parser_)
          this->isPrimary_parser_->pre ();

        return true;
      }

      if (n == "isFlexible" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->isFlexible_parser_;

        if (this->isFlexible_parser_)
          this->isFlexible_parser_->pre ();

        return true;
      }

      if (n == "isMandatory" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->isMandatory_parser_;

        if (this->isMandatory_parser_)
          this->isMandatory_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Activity_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::sim_mob::xml::TripChainItem_t_pskel::_end_element_impl (ns, n))
        return true;

      if (n == "description" && ns.empty ())
      {
        if (this->description_parser_)
          this->description (this->description_parser_->post_string ());

        return true;
      }

      if (n == "location" && ns.empty ())
      {
        if (this->location_parser_)
          this->location (this->location_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "locationType" && ns.empty ())
      {
        if (this->locationType_parser_)
          this->locationType (this->locationType_parser_->post_TripchainItemLocationType ());

        return true;
      }

      if (n == "isPrimary" && ns.empty ())
      {
        if (this->isPrimary_parser_)
          this->isPrimary (this->isPrimary_parser_->post_boolean ());

        return true;
      }

      if (n == "isFlexible" && ns.empty ())
      {
        if (this->isFlexible_parser_)
          this->isFlexible (this->isFlexible_parser_->post_boolean ());

        return true;
      }

      if (n == "isMandatory" && ns.empty ())
      {
        if (this->isMandatory_parser_)
          this->isMandatory (this->isMandatory_parser_->post_boolean ());

        return true;
      }

      return false;
    }

    // TripChain_t_pskel
    //

    void TripChain_t_pskel::
    personID (const ::std::string&)
    {
    }

    void TripChain_t_pskel::
    Trip (sim_mob::TripChainItem*)
    {
    }

    void TripChain_t_pskel::
    Activity (sim_mob::TripChainItem*)
    {
    }

    bool TripChain_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "personID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

        if (this->personID_parser_)
          this->personID_parser_->pre ();

        return true;
      }

      if (n == "Trip" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Trip_parser_;

        if (this->Trip_parser_)
          this->Trip_parser_->pre ();

        return true;
      }

      if (n == "Activity" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Activity_parser_;

        if (this->Activity_parser_)
          this->Activity_parser_->pre ();

        return true;
      }

      return false;
    }

    bool TripChain_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "personID" && ns.empty ())
      {
        if (this->personID_parser_)
          this->personID (this->personID_parser_->post_string ());

        return true;
      }

      if (n == "Trip" && ns.empty ())
      {
        if (this->Trip_parser_)
          this->Trip (this->Trip_parser_->post_Trip_t ());

        return true;
      }

      if (n == "Activity" && ns.empty ())
      {
        if (this->Activity_parser_)
          this->Activity (this->Activity_parser_->post_Activity_t ());

        return true;
      }

      return false;
    }

    // TripChains_t_pskel
    //

    void TripChains_t_pskel::
    TripChain (std::pair<std::string, std::vector<sim_mob::TripChainItem*> >)
    {
    }

    void TripChains_t_pskel::
    post_TripChains_t ()
    {
    }

    bool TripChains_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "TripChain" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChain_parser_;

        if (this->TripChain_parser_)
          this->TripChain_parser_->pre ();

        return true;
      }

      return false;
    }

    bool TripChains_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "TripChain" && ns.empty ())
      {
        if (this->TripChain_parser_)
          this->TripChain (this->TripChain_parser_->post_TripChain_t ());

        return true;
      }

      return false;
    }

    // linkAndCrossing_t_pskel
    //

    void linkAndCrossing_t_pskel::
    ID (unsigned char)
    {
    }

    void linkAndCrossing_t_pskel::
    linkID (unsigned int)
    {
    }

    void linkAndCrossing_t_pskel::
    crossingID (unsigned int)
    {
    }

    void linkAndCrossing_t_pskel::
    angle (unsigned char)
    {
    }

    bool linkAndCrossing_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "ID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ID_parser_;

        if (this->ID_parser_)
          this->ID_parser_->pre ();

        return true;
      }

      if (n == "linkID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

        if (this->linkID_parser_)
          this->linkID_parser_->pre ();

        return true;
      }

      if (n == "crossingID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->crossingID_parser_;

        if (this->crossingID_parser_)
          this->crossingID_parser_->pre ();

        return true;
      }

      if (n == "angle" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->angle_parser_;

        if (this->angle_parser_)
          this->angle_parser_->pre ();

        return true;
      }

      return false;
    }

    bool linkAndCrossing_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "ID" && ns.empty ())
      {
        if (this->ID_parser_)
          this->ID (this->ID_parser_->post_unsigned_byte ());

        return true;
      }

      if (n == "linkID" && ns.empty ())
      {
        if (this->linkID_parser_)
          this->linkID (this->linkID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "crossingID" && ns.empty ())
      {
        if (this->crossingID_parser_)
          this->crossingID (this->crossingID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "angle" && ns.empty ())
      {
        if (this->angle_parser_)
          this->angle (this->angle_parser_->post_unsigned_byte ());

        return true;
      }

      return false;
    }

    // linkAndCrossings_t_pskel
    //

    void linkAndCrossings_t_pskel::
    linkAndCrossing (sim_mob::LinkAndCrossing)
    {
    }

    bool linkAndCrossings_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "linkAndCrossing" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkAndCrossing_parser_;

        if (this->linkAndCrossing_parser_)
          this->linkAndCrossing_parser_->pre ();

        return true;
      }

      return false;
    }

    bool linkAndCrossings_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "linkAndCrossing" && ns.empty ())
      {
        if (this->linkAndCrossing_parser_)
          this->linkAndCrossing (this->linkAndCrossing_parser_->post_linkAndCrossing_t ());

        return true;
      }

      return false;
    }

    // Plan_t_pskel
    //

    void Plan_t_pskel::
    planID (unsigned char)
    {
    }

    void Plan_t_pskel::
    PhasePercentage (double)
    {
    }

    bool Plan_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "planID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->planID_parser_;

        if (this->planID_parser_)
          this->planID_parser_->pre ();

        return true;
      }

      if (n == "PhasePercentage" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PhasePercentage_parser_;

        if (this->PhasePercentage_parser_)
          this->PhasePercentage_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Plan_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "planID" && ns.empty ())
      {
        if (this->planID_parser_)
          this->planID (this->planID_parser_->post_unsigned_byte ());

        return true;
      }

      if (n == "PhasePercentage" && ns.empty ())
      {
        if (this->PhasePercentage_parser_)
          this->PhasePercentage (this->PhasePercentage_parser_->post_double ());

        return true;
      }

      return false;
    }

    // Plans_t_pskel
    //

    void Plans_t_pskel::
    plan (std::pair<short,std::vector<double> >)
    {
    }

    bool Plans_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "plan" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->plan_parser_;

        if (this->plan_parser_)
          this->plan_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Plans_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "plan" && ns.empty ())
      {
        if (this->plan_parser_)
          this->plan (this->plan_parser_->post_Plan_t ());

        return true;
      }

      return false;
    }

    // ColorDuration_t_pskel
    //

    void ColorDuration_t_pskel::
    TrafficColor (sim_mob::TrafficColor)
    {
    }

    void ColorDuration_t_pskel::
    Duration (unsigned char)
    {
    }

    bool ColorDuration_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "TrafficColor" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TrafficColor_parser_;

        if (this->TrafficColor_parser_)
          this->TrafficColor_parser_->pre ();

        return true;
      }

      if (n == "Duration" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Duration_parser_;

        if (this->Duration_parser_)
          this->Duration_parser_->pre ();

        return true;
      }

      return false;
    }

    bool ColorDuration_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "TrafficColor" && ns.empty ())
      {
        if (this->TrafficColor_parser_)
          this->TrafficColor (this->TrafficColor_parser_->post_TrafficColor_t ());

        return true;
      }

      if (n == "Duration" && ns.empty ())
      {
        if (this->Duration_parser_)
          this->Duration (this->Duration_parser_->post_unsigned_byte ());

        return true;
      }

      return false;
    }

    // ColorSequence_t_pskel
    //

    void ColorSequence_t_pskel::
    TrafficLightType (const ::std::string&)
    {
    }

    void ColorSequence_t_pskel::
    ColorDuration (std::pair<sim_mob::TrafficColor,short>)
    {
    }

    bool ColorSequence_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "TrafficLightType" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TrafficLightType_parser_;

        if (this->TrafficLightType_parser_)
          this->TrafficLightType_parser_->pre ();

        return true;
      }

      if (n == "ColorDuration" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorDuration_parser_;

        if (this->ColorDuration_parser_)
          this->ColorDuration_parser_->pre ();

        return true;
      }

      return false;
    }

    bool ColorSequence_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "TrafficLightType" && ns.empty ())
      {
        if (this->TrafficLightType_parser_)
          this->TrafficLightType (this->TrafficLightType_parser_->post_string ());

        return true;
      }

      if (n == "ColorDuration" && ns.empty ())
      {
        if (this->ColorDuration_parser_)
          this->ColorDuration (this->ColorDuration_parser_->post_ColorDuration_t ());

        return true;
      }

      return false;
    }

    // links_maps_t_pskel
    //

    void links_maps_t_pskel::
    links_map (std::pair<sim_mob::Link*,sim_mob::linkToLink>)
    {
    }

    bool links_maps_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "links_map" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->links_map_parser_;

        if (this->links_map_parser_)
          this->links_map_parser_->pre ();

        return true;
      }

      return false;
    }

    bool links_maps_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "links_map" && ns.empty ())
      {
        if (this->links_map_parser_)
          this->links_map (this->links_map_parser_->post_links_map_t ());

        return true;
      }

      return false;
    }

    // links_map_t_pskel
    //

    void links_map_t_pskel::
    linkFrom (unsigned int)
    {
    }

    void links_map_t_pskel::
    linkTo (unsigned int)
    {
    }

    void links_map_t_pskel::
    SegmentFrom (unsigned int)
    {
    }

    void links_map_t_pskel::
    SegmentTo (unsigned int)
    {
    }

    void links_map_t_pskel::
    ColorSequence (std::pair<sim_mob::TrafficLightType, std::vector<std::pair<TrafficColor,short> > >)
    {
    }

    bool links_map_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "linkFrom" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkFrom_parser_;

        if (this->linkFrom_parser_)
          this->linkFrom_parser_->pre ();

        return true;
      }

      if (n == "linkTo" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkTo_parser_;

        if (this->linkTo_parser_)
          this->linkTo_parser_->pre ();

        return true;
      }

      if (n == "SegmentFrom" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentFrom_parser_;

        if (this->SegmentFrom_parser_)
          this->SegmentFrom_parser_->pre ();

        return true;
      }

      if (n == "SegmentTo" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentTo_parser_;

        if (this->SegmentTo_parser_)
          this->SegmentTo_parser_->pre ();

        return true;
      }

      if (n == "ColorSequence" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorSequence_parser_;

        if (this->ColorSequence_parser_)
          this->ColorSequence_parser_->pre ();

        return true;
      }

      return false;
    }

    bool links_map_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "linkFrom" && ns.empty ())
      {
        if (this->linkFrom_parser_)
          this->linkFrom (this->linkFrom_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "linkTo" && ns.empty ())
      {
        if (this->linkTo_parser_)
          this->linkTo (this->linkTo_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "SegmentFrom" && ns.empty ())
      {
        if (this->SegmentFrom_parser_)
          this->SegmentFrom (this->SegmentFrom_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "SegmentTo" && ns.empty ())
      {
        if (this->SegmentTo_parser_)
          this->SegmentTo (this->SegmentTo_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "ColorSequence" && ns.empty ())
      {
        if (this->ColorSequence_parser_)
          this->ColorSequence (this->ColorSequence_parser_->post_ColorSequence_t ());

        return true;
      }

      return false;
    }

    // crossings_maps_t_pskel
    //

    void crossings_maps_t_pskel::
    crossings_map (std::pair<sim_mob::Crossing *, sim_mob::Crossings>)
    {
    }

    bool crossings_maps_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "crossings_map" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->crossings_map_parser_;

        if (this->crossings_map_parser_)
          this->crossings_map_parser_->pre ();

        return true;
      }

      return false;
    }

    bool crossings_maps_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "crossings_map" && ns.empty ())
      {
        if (this->crossings_map_parser_)
          this->crossings_map (this->crossings_map_parser_->post_crossings_map_t ());

        return true;
      }

      return false;
    }

    // crossings_map_t_pskel
    //

    void crossings_map_t_pskel::
    linkID (unsigned int)
    {
    }

    void crossings_map_t_pskel::
    crossingID (unsigned int)
    {
    }

    void crossings_map_t_pskel::
    ColorSequence (std::pair<sim_mob::TrafficLightType, std::vector<std::pair<TrafficColor,short> > >)
    {
    }

    bool crossings_map_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "linkID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

        if (this->linkID_parser_)
          this->linkID_parser_->pre ();

        return true;
      }

      if (n == "crossingID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->crossingID_parser_;

        if (this->crossingID_parser_)
          this->crossingID_parser_->pre ();

        return true;
      }

      if (n == "ColorSequence" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorSequence_parser_;

        if (this->ColorSequence_parser_)
          this->ColorSequence_parser_->pre ();

        return true;
      }

      return false;
    }

    bool crossings_map_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "linkID" && ns.empty ())
      {
        if (this->linkID_parser_)
          this->linkID (this->linkID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "crossingID" && ns.empty ())
      {
        if (this->crossingID_parser_)
          this->crossingID (this->crossingID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "ColorSequence" && ns.empty ())
      {
        if (this->ColorSequence_parser_)
          this->ColorSequence (this->ColorSequence_parser_->post_ColorSequence_t ());

        return true;
      }

      return false;
    }

    // Phase_t_pskel
    //

    void Phase_t_pskel::
    phaseID (unsigned char)
    {
    }

    void Phase_t_pskel::
    name (const ::std::string&)
    {
    }

    void Phase_t_pskel::
    links_maps (std::multimap<sim_mob::Link*,sim_mob::linkToLink>)
    {
    }

    void Phase_t_pskel::
    crossings_maps (std::map<sim_mob::Crossing *, sim_mob::Crossings>)
    {
    }

    bool Phase_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "phaseID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->phaseID_parser_;

        if (this->phaseID_parser_)
          this->phaseID_parser_->pre ();

        return true;
      }

      if (n == "name" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

        if (this->name_parser_)
          this->name_parser_->pre ();

        return true;
      }

      if (n == "links_maps" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->links_maps_parser_;

        if (this->links_maps_parser_)
          this->links_maps_parser_->pre ();

        return true;
      }

      if (n == "crossings_maps" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->crossings_maps_parser_;

        if (this->crossings_maps_parser_)
          this->crossings_maps_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Phase_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "phaseID" && ns.empty ())
      {
        if (this->phaseID_parser_)
          this->phaseID (this->phaseID_parser_->post_unsigned_byte ());

        return true;
      }

      if (n == "name" && ns.empty ())
      {
        if (this->name_parser_)
          this->name (this->name_parser_->post_string ());

        return true;
      }

      if (n == "links_maps" && ns.empty ())
      {
        if (this->links_maps_parser_)
          this->links_maps (this->links_maps_parser_->post_links_maps_t ());

        return true;
      }

      if (n == "crossings_maps" && ns.empty ())
      {
        if (this->crossings_maps_parser_)
          this->crossings_maps (this->crossings_maps_parser_->post_crossings_maps_t ());

        return true;
      }

      return false;
    }

    // Phases_t_pskel
    //

    void Phases_t_pskel::
    phase (sim_mob::Phase)
    {
    }

    bool Phases_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "phase" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->phase_parser_;

        if (this->phase_parser_)
          this->phase_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Phases_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "phase" && ns.empty ())
      {
        if (this->phase_parser_)
          this->phase (this->phase_parser_->post_Phase_t ());

        return true;
      }

      return false;
    }

    // SplitPlan_t_pskel
    //

    void SplitPlan_t_pskel::
    splitplanID (unsigned int)
    {
    }

    void SplitPlan_t_pskel::
    cycleLength (unsigned char)
    {
    }

    void SplitPlan_t_pskel::
    offset (unsigned char)
    {
    }

    void SplitPlan_t_pskel::
    ChoiceSet (std::vector<std::vector<double> >)
    {
    }

    bool SplitPlan_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "splitplanID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->splitplanID_parser_;

        if (this->splitplanID_parser_)
          this->splitplanID_parser_->pre ();

        return true;
      }

      if (n == "cycleLength" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->cycleLength_parser_;

        if (this->cycleLength_parser_)
          this->cycleLength_parser_->pre ();

        return true;
      }

      if (n == "offset" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

        if (this->offset_parser_)
          this->offset_parser_->pre ();

        return true;
      }

      if (n == "ChoiceSet" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ChoiceSet_parser_;

        if (this->ChoiceSet_parser_)
          this->ChoiceSet_parser_->pre ();

        return true;
      }

      return false;
    }

    bool SplitPlan_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "splitplanID" && ns.empty ())
      {
        if (this->splitplanID_parser_)
          this->splitplanID (this->splitplanID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "cycleLength" && ns.empty ())
      {
        if (this->cycleLength_parser_)
          this->cycleLength (this->cycleLength_parser_->post_unsigned_byte ());

        return true;
      }

      if (n == "offset" && ns.empty ())
      {
        if (this->offset_parser_)
          this->offset (this->offset_parser_->post_unsigned_byte ());

        return true;
      }

      if (n == "ChoiceSet" && ns.empty ())
      {
        if (this->ChoiceSet_parser_)
          this->ChoiceSet (this->ChoiceSet_parser_->post_Plans_t ());

        return true;
      }

      return false;
    }

    // SCATS_t_pskel
    //

    void SCATS_t_pskel::
    signalTimingMode (int)
    {
    }

    void SCATS_t_pskel::
    SplitPlan (sim_mob::SplitPlan)
    {
    }

    bool SCATS_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "signalTimingMode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->signalTimingMode_parser_;

        if (this->signalTimingMode_parser_)
          this->signalTimingMode_parser_->pre ();

        return true;
      }

      if (n == "SplitPlan" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SplitPlan_parser_;

        if (this->SplitPlan_parser_)
          this->SplitPlan_parser_->pre ();

        return true;
      }

      return false;
    }

    bool SCATS_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "signalTimingMode" && ns.empty ())
      {
        if (this->signalTimingMode_parser_)
          this->signalTimingMode (this->signalTimingMode_parser_->post_signalTimingMode_t ());

        return true;
      }

      if (n == "SplitPlan" && ns.empty ())
      {
        if (this->SplitPlan_parser_)
          this->SplitPlan (this->SplitPlan_parser_->post_SplitPlan_t ());

        return true;
      }

      return false;
    }

    // Signal_t_pskel
    //

    void Signal_t_pskel::
    signalID (unsigned int)
    {
    }

    void Signal_t_pskel::
    nodeID (unsigned int)
    {
    }

    void Signal_t_pskel::
    linkAndCrossings (sim_mob::LinkAndCrossingC)
    {
    }

    void Signal_t_pskel::
    phases (sim_mob::Signal::phases)
    {
    }

    void Signal_t_pskel::
    SCATS (sim_mob::xml::helper::SignalHelper::SCATS_Info)
    {
    }

    bool Signal_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "signalID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->signalID_parser_;

        if (this->signalID_parser_)
          this->signalID_parser_->pre ();

        return true;
      }

      if (n == "nodeID" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

        if (this->nodeID_parser_)
          this->nodeID_parser_->pre ();

        return true;
      }

      if (n == "linkAndCrossings" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->linkAndCrossings_parser_;

        if (this->linkAndCrossings_parser_)
          this->linkAndCrossings_parser_->pre ();

        return true;
      }

      if (n == "phases" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->phases_parser_;

        if (this->phases_parser_)
          this->phases_parser_->pre ();

        return true;
      }

      if (n == "SCATS" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SCATS_parser_;

        if (this->SCATS_parser_)
          this->SCATS_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Signal_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "signalID" && ns.empty ())
      {
        if (this->signalID_parser_)
          this->signalID (this->signalID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "nodeID" && ns.empty ())
      {
        if (this->nodeID_parser_)
          this->nodeID (this->nodeID_parser_->post_unsigned_int ());

        return true;
      }

      if (n == "linkAndCrossings" && ns.empty ())
      {
        if (this->linkAndCrossings_parser_)
          this->linkAndCrossings (this->linkAndCrossings_parser_->post_linkAndCrossings_t ());

        return true;
      }

      if (n == "phases" && ns.empty ())
      {
        if (this->phases_parser_)
          this->phases (this->phases_parser_->post_Phases_t ());

        return true;
      }

      if (n == "SCATS" && ns.empty ())
      {
        if (this->SCATS_parser_)
          this->SCATS (this->SCATS_parser_->post_SCATS_t ());

        return true;
      }

      return false;
    }

    // Signals_t_pskel
    //

    void Signals_t_pskel::
    Signal (sim_mob::Signal*)
    {
    }

    bool Signals_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Signal" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Signal_parser_;

        if (this->Signal_parser_)
          this->Signal_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Signals_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Signal" && ns.empty ())
      {
        if (this->Signal_parser_)
          this->Signal (this->Signal_parser_->post_Signal_t ());

        return true;
      }

      return false;
    }

    // GeoSpatial_t_pskel
    //

    void GeoSpatial_t_pskel::
    RoadNetwork (sim_mob::RoadNetwork&)
    {
    }

    void GeoSpatial_t_pskel::
    post_GeoSpatial_t ()
    {
    }

    bool GeoSpatial_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "RoadNetwork" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadNetwork_parser_;

        if (this->RoadNetwork_parser_)
          this->RoadNetwork_parser_->pre ();

        return true;
      }

      return false;
    }

    bool GeoSpatial_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "RoadNetwork" && ns.empty ())
      {
        if (this->RoadNetwork_parser_)
          this->RoadNetwork (this->RoadNetwork_parser_->post_RoadNetwork_t ());

        return true;
      }

      return false;
    }

    // SimMobility_t_pskel
    //

    void SimMobility_t_pskel::
    GeoSpatial ()
    {
    }

    void SimMobility_t_pskel::
    TripChains ()
    {
    }

    void SimMobility_t_pskel::
    Signals (std::vector<sim_mob::Signal*>)
    {
    }

    void SimMobility_t_pskel::
    post_SimMobility_t ()
    {
    }

    bool SimMobility_t_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "GeoSpatial" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->GeoSpatial_parser_;

        if (this->GeoSpatial_parser_)
          this->GeoSpatial_parser_->pre ();

        return true;
      }

      if (n == "TripChains" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChains_parser_;

        if (this->TripChains_parser_)
          this->TripChains_parser_->pre ();

        return true;
      }

      if (n == "Signals" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Signals_parser_;

        if (this->Signals_parser_)
          this->Signals_parser_->pre ();

        return true;
      }

      return false;
    }

    bool SimMobility_t_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "GeoSpatial" && ns.empty ())
      {
        if (this->GeoSpatial_parser_)
        {
          this->GeoSpatial_parser_->post_GeoSpatial_t ();
          this->GeoSpatial ();
        }

        return true;
      }

      if (n == "TripChains" && ns.empty ())
      {
        if (this->TripChains_parser_)
        {
          this->TripChains_parser_->post_TripChains_t ();
          this->TripChains ();
        }

        return true;
      }

      if (n == "Signals" && ns.empty ())
      {
        if (this->Signals_parser_)
          this->Signals (this->Signals_parser_->post_Signals_t ());

        return true;
      }

      return false;
    }

    // Lanes_pskel
    //

    void Lanes_pskel::
    Lane (sim_mob::Lane*)
    {
    }

    bool Lanes_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Lane" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Lane_parser_;

        if (this->Lane_parser_)
          this->Lane_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Lanes_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Lane" && ns.empty ())
      {
        if (this->Lane_parser_)
          this->Lane (this->Lane_parser_->post_lane_t ());

        return true;
      }

      return false;
    }

    // Nodes_pskel
    //

    void Nodes_pskel::
    UniNodes (const std::set<sim_mob::UniNode*>&)
    {
    }

    void Nodes_pskel::
    Intersections (const std::vector<sim_mob::MultiNode*>&)
    {
    }

    void Nodes_pskel::
    roundabouts (const std::vector<sim_mob::MultiNode*>&)
    {
    }

    bool Nodes_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "UniNodes" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNodes_parser_;

        if (this->UniNodes_parser_)
          this->UniNodes_parser_->pre ();

        return true;
      }

      if (n == "Intersections" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersections_parser_;

        if (this->Intersections_parser_)
          this->Intersections_parser_->pre ();

        return true;
      }

      if (n == "roundabouts" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabouts_parser_;

        if (this->roundabouts_parser_)
          this->roundabouts_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Nodes_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "UniNodes" && ns.empty ())
      {
        if (this->UniNodes_parser_)
          this->UniNodes (this->UniNodes_parser_->post_UniNodes ());

        return true;
      }

      if (n == "Intersections" && ns.empty ())
      {
        if (this->Intersections_parser_)
          this->Intersections (this->Intersections_parser_->post_Intersections ());

        return true;
      }

      if (n == "roundabouts" && ns.empty ())
      {
        if (this->roundabouts_parser_)
          this->roundabouts (this->roundabouts_parser_->post_roundabouts ());

        return true;
      }

      return false;
    }

    // Links_pskel
    //

    void Links_pskel::
    Link (sim_mob::Link*)
    {
    }

    bool Links_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Link" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Link_parser_;

        if (this->Link_parser_)
          this->Link_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Links_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Link" && ns.empty ())
      {
        if (this->Link_parser_)
          this->Link (this->Link_parser_->post_link_t ());

        return true;
      }

      return false;
    }

    // UniNodes_pskel
    //

    void UniNodes_pskel::
    UniNode (sim_mob::UniNode*)
    {
    }

    bool UniNodes_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "UniNode" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNode_parser_;

        if (this->UniNode_parser_)
          this->UniNode_parser_->pre ();

        return true;
      }

      return false;
    }

    bool UniNodes_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "UniNode" && ns.empty ())
      {
        if (this->UniNode_parser_)
          this->UniNode (this->UniNode_parser_->post_UniNode_t ());

        return true;
      }

      return false;
    }

    // Intersections_pskel
    //

    void Intersections_pskel::
    Intersection (sim_mob::MultiNode*)
    {
    }

    bool Intersections_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "Intersection" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersection_parser_;

        if (this->Intersection_parser_)
          this->Intersection_parser_->pre ();

        return true;
      }

      return false;
    }

    bool Intersections_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "Intersection" && ns.empty ())
      {
        if (this->Intersection_parser_)
          this->Intersection (this->Intersection_parser_->post_intersection_t ());

        return true;
      }

      return false;
    }

    // roundabouts_pskel
    //

    void roundabouts_pskel::
    roundabout (sim_mob::MultiNode*)
    {
    }

    bool roundabouts_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;

      if (n == "roundabout" && ns.empty ())
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabout_parser_;

        if (this->roundabout_parser_)
          this->roundabout_parser_->pre ();

        return true;
      }

      return false;
    }

    bool roundabouts_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
        return true;

      if (n == "roundabout" && ns.empty ())
      {
        if (this->roundabout_parser_)
          this->roundabout (this->roundabout_parser_->post_roundabout_t ());

        return true;
      }

      return false;
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

